[{"title":"sys_brk","path":"/2025/11/12/sys-brk/","content":"sys_brk（即调用号为12的brk系统调用）是Linux中一个用于动态内存管理的核心系统调用。它直接操作进程的程序中断点（program break），即堆（heap）的结束地址。通过改变这个中断点的位置，程序可以动态地增加或减少其数据段的大小。尽管现代C库（如glibc）通常使用mmap来实现更灵活的内存分配（如malloc），但在底层，sys_brk仍然是扩展堆空间的基本机制。了解sys_brk有助于理解进程地址空间的布局，以及操作系统如何为程序提供可变大小的内存区域。 sys_brk 函数原型 int brk(void *addr); 参数 addr: 新的程序中断点地址。如果该地址比当前中断点高，则扩大堆；如果比当前中断点低，则缩小堆。如果传入0，系统调用会返回当前程序中断点的地址。 返回值 成功时返回新程序中断点地址（即参数addr）。但对于现代x86_64 Linux，为了与旧版内核兼容，返回值在rax中会是0，失败时会是1。 失败时返回-1，并设置errno（如ENOMEM）。 用例 .equ SYS_BRK, 12\t.equ SYS_WRITE, 1\t.equ SYS_EXIT, 60\t.equ STDOUT, 1\t.equ PAGE_SIZE, 4096\t.section .datainitial_brk:\t.quad 0x0message:\t.ascii New memory allocated with sys_brk. \\0\tmsg_len = . - message\t.section .text\t.globl _start_start:\t# 获取当前程序中断点地址\tmov $SYS_BRK, %rax\txor %rdi, %rdi\tsyscall\t# 检查返回值以确保成功\tcmp $0, %rax\tje exit_error\t# 将当前中断点地址保存起来\tmov %rax, initial_brk(%rip)\t# 计算新的中断点地址（增加一个页大小）\tadd $PAGE_SIZE, %rax\t# 调用 sys_brk 扩展堆\tmov $SYS_BRK, %rax\tmov initial_brk(%rip), %rdi\tadd $PAGE_SIZE, %rdi\tsyscall\t# 检查返回值，如果失败则退出\tcmp $0, %rax\tjne exit_error\t# 将消息复制到新分配的内存区域\tmov initial_brk(%rip), %rdi\tmov $message, %rsi\tmov $msg_len, %rcx\tcld\trep movsb\t# 使用 sys_write 打印新内存中的消息\tmov $SYS_WRITE, %rax\tmov $STDOUT, %rdi\tmov initial_brk(%rip), %rsi\tmov $msg_len, %rdx\tsyscall# 退出程序exit_success:\tmov $SYS_EXIT, %rax\txor %rdi, %rdi\tsyscallexit_error:\tmov $SYS_EXIT, %rax\tmov $1, %rdi\tsyscall 分析： 上述代码演示了如何使用sys_brk系统调用来动态地扩大堆内存。 首先，程序通过调用brk(0)来获取当前的程序中断点地址。在汇编中，这是通过将系统调用号12放入%rax并将%rdi设置为0来完成的。返回的地址会保存在%rax中，程序将其存储在initial_brk变量中。 接着，程序将initial_brk的值增加一个页面大小（4096字节），得到新的中断点地址。然后，它再次调用sys_brk，并将这个新的地址作为参数传递。如果调用成功，内核会调整堆的大小，使程序可以使用这块新分配的内存。 最后，程序将一个字符串消息复制到这个新分配的内存区域，并使用sys_write系统调用将其打印到标准输出。这证明了通过sys_brk分配的内存现在是可访问和可写入的。","tags":["Linux, Kernel"]},{"title":"sys_mprotect","path":"/2025/11/12/sys-mprotect/","content":"sys_mprotect（即调用号为10的mprotect系统调用）是Linux内核提供的一个核心功能，它允许程序动态地修改其虚拟地址空间中某个内存区域的访问权限。这在很多场景中都至关重要，如实现JIT编译器、沙箱机制，或者防止某些类型的缓冲区溢出攻击。通过调用sys_mprotect，程序可以将一段内存设置为只读，以保护重要数据不被意外修改；或者将一段内存设置为可执行，以允许动态生成的代码运行。理解这个系统调用有助于深入理解现代操作系统的内存管理和安全机制。 sys_mprotect 函数原型 int mprotect(const void *addr, size_t len, int prot); 参数 addr: 要修改权限的内存区域的起始地址。这个地址必须是页对齐的，否则系统调用会失败并返回EINVAL错误。 len: 要修改权限的内存区域的长度（字节）。这个长度也必须是页大小的整数倍。 prot：映射区域的访问权限： PROT_NONE：页面不可访问 PROT_READ：页面可读 PROT_WRITE：页面可写 PROT_EXEC：页面可执行 PROT_SEM：页面可用于原子操作同步（自 Linux 2.5.7 起支持） 💡 备注：prot 取值的宏定义如下： #define PROT_NONE 0x0#define PROT_READ 0x1#define PROT_WRITE 0x2#define PROT_EXEC 0x4#define PROT_SEM 0x8#define PROT_GROWSDOWN 0x01000000#define PROT_GROWSUP 0x02000000 各个宏之间使用按位或运算符 | 进行连接。 返回值 成功时返回0。 失败时返回-1，并设置errno（如ENOMEM, EFAULT, EINVAL, EACCES）。 用例 .equ SYS_MPROTECT, 10\t.equ SYS_EXIT, 60\t.equ PROT_READ, 0x01\t.equ PROT_READ_WRITE, 0x03\t.equ PAGE_SIZE, 4096\t.section .data\t.p2align 12 # 强制页对齐my_page:\t.ascii This is a memory page to be protected.\\ .space (PAGE_SIZE - (. - my_page)) # 填充到页大小\t.section .text\t.globl _start_start:\t# 将 my_page 设置为只读\tmov $SYS_MPROTECT, %rax\tlea my_page(%rip), %rdi # addr = my_page\tmov $PAGE_SIZE, %rsi # len = 4096\tmov $PROT_READ, %rdx # prot = PROT_READ\tsyscall\t# 检查返回值（%rax），如果失败则退出\tcmp $0, %rax\tjne exit_error\t# 这里可以尝试向 my_page 中写入内容\t# call write_page # 现在尝试将 my_page 设置为可读写\tmov $SYS_MPROTECT, %rax\tlea my_page(%rip), %rdi # addr = my_page\tmov $PAGE_SIZE, %rsi # len = 4096\tmov $PROT_READ_WRITE, %rdx # prot = PROT_READ | PROT_WRITE\tsyscall\t# 这里可以再次尝试向 my_page 中写入内容\tcall write_page# 退出程序exit_success:\tmov $SYS_EXIT, %rax\txor %rdi, %rdi\tsyscallexit_error:\tmov $SYS_EXIT, %rax\tmov $1, %rdi\tsyscall# 尝试修改 my_page 这段内存中第一个字节的值write_page:\tlea my_page(%rip), %rdi\tmov $0, (%rdi)\tret 分析： 上述代码演示了如何使用sys_mprotect来动态改变内存区域的权限。 程序首先在.data段定义了一个名为my_page的内存区域，并使用.p2align 12指令确保其地址是4096字节（即一个内存页）的整数倍对齐。然后，它用.space指令填充剩余空间，使该区域恰好为一个页的大小。 接下来，程序调用sys_mprotect，将my_page的地址加载到%rdi，长度PAGE_SIZE加载到%rsi，并将权限标志PROT_READ（只读）加载到%rdx。执行syscall后，my_page这块内存将变为只读。 如上，我们可以在这个时候尝试call write_page ，但是由于前面已经将这块目标内存设置为只读，修改操作不会生效，且会触发段错误SIGSEGV 造成整个程序的强制性崩溃。反之，如果我们在前面不调用sys_mprotect ，而在这里尝试call write_page ，程序并不会报错，且可以实现对内存的正常修改。 在这之后，程序再次调用sys_mprotect，将权限标志更新为PROT_READ | PROT_WRITE，从而将my_page的权限从只读修改为可读写。此时再尝试call write_page ，发现内存可以被正常修改，且不会触发段错误。 整个过程展示了sys_mprotect如何灵活地控制内存权限，这在底层编程中非常有用。","tags":["Linux, Kernel"]},{"title":"sys_mmap 与 sys_munmap","path":"/2025/11/12/sys-mmap-与-sys-munmap/","content":"sys_mmap（调用号为9）和sys_munmap （调用号为11）是 Linux 中功能最强大的内存管理接口之一。二者分别可用于将文件或匿名内存映射到进程的虚拟地址空间以及取消前者所建立的映射，从而实现文件 IO 的内存语义、堆外大块内存分配、共享内存、线程栈空间分配等功能。 sys_mmap 函数原型 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 参数 addr：建议的映射起始地址（通常传 NULL，即让内核自动选择合适的地址）。 如果与 MAP_FIXED 标志一起使用，则必须是页对齐地址，且会覆盖该处原有映射。 length：映射的字节数。内核会向上取整到页大小的倍数。 prot：映射区域的访问权限（可按位或组合）： PROT_NONE：页面不可访问 PROT_READ：页面可读 PROT_WRITE：页面可写 PROT_EXEC：页面可执行 PROT_SEM：页面可用于原子操作同步（自 Linux 2.5.7 起支持） flags：映射的类型和属性（可按位或组合）： 基本属性 MAP_SHARED：修改共享到文件或其它进程 MAP_PRIVATE：写时复制（COW），修改不会影响底层文件 地址控制 MAP_FIXED：强制在 addr 指定位置映射，若冲突则覆盖（危险） MAP_FIXED_NOREPLACE：强制映射但不覆盖已有区域（Linux 4.17+） MAP_32BIT：将映射放在低 2GB 地址空间 MAP_STACK：提示内核将区域当作栈（自动增长） 匿名特殊 MAP_ANONYMOUS：匿名映射（不依赖文件），fd 必须为 1 MAP_GROWSDOWN：向下增长（栈使用） MAP_HUGETLB：使用大页内存（HugeTLB） 性能控制 MAP_POPULATE：立即预取（触发缺页加载） MAP_NONBLOCK：结合 MAP_POPULATE，后台加载 MAP_NORESERVE：不为交换区预留空间 MAP_LOCKED：将映射锁定在物理内存中 MAP_SYNC：与持久化存储同步（需 DAX 支持） MAP_UNINITIALIZED：允许返回未清零内存（仅某些内核配置） 💡 备注：prot 和 flags 的宏定义如下： #define PROT_NONE 0x0#define PROT_READ 0x1#define PROT_WRITE 0x2#define PROT_EXEC 0x4#define PROT_SEM 0x8#define PROT_GROWSDOWN 0x01000000#define PROT_GROWSUP 0x02000000#define MAP_SHARED 0x01#define MAP_PRIVATE 0x02#define MAP_FIXED 0x10#define MAP_ANONYMOUS 0x20#define MAP_32BIT 0x40#define MAP_GROWSDOWN 0x0100#define MAP_DENYWRITE 0x0800#define MAP_EXECUTABLE 0x1000#define MAP_LOCKED 0x2000#define MAP_NORESERVE 0x4000#define MAP_POPULATE 0x8000#define MAP_NONBLOCK 0x10000#define MAP_STACK 0x20000#define MAP_HUGETLB 0x40000#define MAP_SYNC 0x80000#define MAP_FIXED_NOREPLACE 0x100000#define MAP_UNINITIALIZED 0x200000 在 C 语言的程序实现中，各个宏使用按位或运算符 | 连接。 fd：文件描述符。如果是匿名映射，则必须为 1。 offset：文件中映射的起始偏移，必须是页大小的整数倍。 返回值 成功时返回映射区的起始地址（void * 指针）。 失败时返回-1 并设置errno。 sys_munmap 函数原型 int munmap(void *addr, size_t length); 参数 addr：要取消的映射区的起始地址。 length：映射的字节数。 返回值 成功时返回0 。 失败时返回-1 并设置errno 。 用例 .equ MAP_SHARED, 0x01\t.equ PROT_READ, 0x01\t.equ PROT_WRITE, 0x02\t.equ PROT_READ_WRITE, 0x03\t.section .datafilename:\t.ascii /tmp/test.txt\\0mmap_msg:\t.ascii Data from mmap \\0\tmmap_msg_len = . - mmap_msgwrite_msg:\t.ascii \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\twrite_msg_len = . - write_msgerrmsg:\t.ascii Error \\0\terrmsg_len = . - errmsg\t.section .bss\t.lcomm mapped_addr, 8 # 存储映射的地址\t.lcomm fd, 4\t.section .text\t.globl _start_start:\t# 开启一个文件描述符 %r12 读取 /tmp/test.txt\tmov $2, %rax\tlea filename(%rip), %rdi\tmov $0x242, %rsi\tmov $0644, %rdx\tsyscall\tmov %rax, fd(%rip)\t# 调用 write 往文件中写入数据\tmov $1, %rax\tmov fd(%rip), %rdi\tlea write_msg(%rip), %rsi\tmov $write_msg_len, %rdx\tsyscall\t# 调用 mmap 将文件映射到内存\tmov $9, %rax\txor %rdi, %rdi # addr = NULL\tmov $mmap_msg_len, %rsi # length = msg_len\tmov $PROT_READ_WRITE, %rdx # prot = PROT_READ | PROT_WRITE\tmov $MAP_SHARED, %r10 # flags = MAP_SHARED\tmov fd(%rip), %r8 # fd\txor %r9, %r9 # offset = 0\tsyscall\t# 检查 mmap 是否出错\tcmp $-1, %rax\tjle exit_error\t# 将 mmap 返回的地址保存到 mapped_addr\tmov %rax, mapped_addr(%rip)\t# 将数据从 msg 复制到映射的内存区域\tmov mapped_addr(%rip), %rdi # 目标地址 (dst) = mapped_addr\tlea mmap_msg(%rip), %rsi # 源地址 (src) = message\tmov $mmap_msg_len, %rcx # 复制长度 (count) = msg_len\tcld # 清除方向标志\trep movsb # 循环复制字节\t# 关闭映射\tmov $11, %rax\tmov mapped_addr(%rip), %rdi\tmov $mmap_msg_len, %rsi\tsyscall\t# 关闭文件描述符\tmov $3, %rax\tmov fd(%rip), %rdi\tsyscall\t# 退出程序\tmov $60, %rax\txor %rdi, %rdi\tsyscallexit_error:\tmov %rax, %r12\tmov $1, %rax\tmov $2, %rdi\tlea errmsg(%rip), %rsi\tmov $errmsg_len, %rdx\tsyscall\tmov $60, %rax\tmov %r12, %rdi\tsyscall 分析： 上述代码演示了如何使用sys_mmap 与sys_munmap 将一个文件映射到进程的内存空间。 程序最开始通过调用open 和write ，先是创建了目标文件，然后向该文件中写入了一段较长的字符串，内容为十四个空位\\0 ，目的是为了先填充文件大小至14个字节，以防止爆出总线错误SIGBUS。 程序在调用mmap 时将系统调用号9（sys_mmap）存入%rax。然后，它依次将各个参数加载到相应的寄存器：addr (%rdi)设为0（NULL），让内核自动选择地址；length (%rsi)设为msg_len；prot (%rdx)设为可读写权限；flags (%r10)设为MAP_SHARED；fd (%r8)设置为先前打开的文件描述符；offset (%r9)设为0。等效为： void * mapped_addr = mmap(NULL, msg_len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); 执行syscall后，如果成功，%rax中将包含映射区域的起始地址。程序将这个地址保存起来，然后可以使用它来读写文件，就像读写普通内存一样。 在执行完上述操作之后，程序又调用了munmap 关闭了前面建立的映射，并关闭了整个程序。","tags":["Linux, Kernel"]},{"title":"sys_lseek","path":"/2025/11/12/sys-lseek/","content":"sys_lseek （调用号为8）是 Linux 中一个用于操作文件描述符读写位置的系统调用。它的核心功能是重新定位（移动）一个已打开文件的读写偏移量（offset）。这个偏移量决定了下一次读或写操作将从文件的什么位置开始。通过它，我们可以实现文件的随机访问（即跳转到文件任意位置进行读写），而不仅仅是顺序读写。 sys_lseek 函数原型 off_t lseek(int fd, off_t offset, int whence); 参数 fd: 文件描述符，指向一个已打开的文件。 offset: 相对于 whence 参数的偏移量，以字节为单位。 whence: 决定偏移量计算起点的位置，可取以下值： SEEK_SET (0): 将偏移量设置为从文件开始算起的 offset 字节。 SEEK_CUR (1): 将偏移量设置为从当前位置算起加上 offset 字节（offset 可为负数，表示向前移动）。 SEEK_END (2): 将偏移量设置为从文件末尾算起加上 offset 字节（offset 可为负数，表示向前移动）。 返回值 成功时返回新的、移动后的文件偏移量（从文件开头计算的字节数）。 失败时返回 -errno（如 EBADF ，EINVAL ）。 用例 .section .datafilename:\t.ascii /tmp/text.txt\\0content:\t.ascii HelloWorld\\0 # 文件内容\tlen = . - contentbuffer:\t.space 5 # 用于读取数据的缓冲区.section .text.globl _start_start:\t# 1. 打开文件 (sys_open)\tmov $2, %rax # 系统调用号 (2 = sys_open)\tlea filename(%rip), %rdi # 文件名\tmov $0101, %si # 标志位 (O_CREAT | O_WRONLY)\tmov $0666, %dx # 模式\tsyscall\tmov %rax, %r8 # 保存文件描述符到 %r8\t# 2. 写入内容 content (sys_write)\tmov $1, %rax # 系统调用号 (1 = sys_write)\tmov %r8, %rdi # 文件描述符\tlea content(%rip), %rsi # 要写入的数据\tmov $len, %rdx # 数据长度\tsyscall\t# 3. 关闭文件 (sys_close)\tmov $3, %rax # 系统调用号 (3 = sys_close)\tmov %r8, %rdi\tsyscall\t# 4. 重新以只读方式打开文件 (sys_open)\tmov $2, %rax\tlea filename(%rip), %rdi\txor %rsi, %rsi # 标志位 (O_RDONLY)\tsyscall\tmov %rax, %r8 # 保存新的文件描述符\t# 5. 使用 sys_lseek 跳转到第6个字节（W的位置）\tmov $8, %rax # 系统调用号 (8 = sys_lseek)\tmov %r8, %rdi # 文件描述符\tmov $5, %rsi # offset = 5 (从起点后第5个字节，即第6个)\tmov $0, %rdx # whence = SEEK_SET (0)\tsyscall\t# 6. 从新位置读取5个字节 (sys_read)\tmov $0, %rax # 系统调用号 (0 = sys_read)\tmov %r8, %rdi\tlea buffer(%rip), %rsi # 读取缓冲区\tmov $5, %rdx # 读取5个字节\tsyscall\t# 7. 将读取到的内容输出到标准输出 (sys_write)\tmov $1, %rax\tmov $1, %rdi # 文件描述符 (1 = stdout)\tlea buffer(%rip), %rsi\tmov $5, %rdx\tsyscall\t# 8. 关闭文件并退出\tmov $3, %rax # sys_close\tmov %r8, %rdi\tsyscall\tmov $60, %rax # sys_exit\txor %rdi, %rdi\tsyscall 分析： 上述代码演示了 sys_lseek 的一个典型用法：跳转到文件中间进行读取。 程序首先创建并打开一个名为 test.txt 的文件，写入字符串 HelloWorld（共 10 字节），然后关闭它。然后，重新以只读模式打开该文件。此时文件偏移量在开头 (0)。此时，程序开始调用 sys_lseek。我们首先将，系统调用号 8 存入 %rax ，文件描述符存入 %rdi ，偏移量 5 存入 %rsi（我们希望跳过前5个字节 Hello），whence 参数 SEEK_SET (0) 存入 %rdx，表示从文件开头计算偏移。 执行后，文件偏移量被设置为 5。紧接着调用 sys_read，它会从新的偏移量（第 5 字节后，即第 6 个字节）开始读取。这里读取了 5 个字节，内容将是 World。随后，程序开始将这个结果 World 写入标准输出。最终效果是，程序没有读取文件的开头，而是直接读取并输出了文件的后半部分。","tags":["Linux, Kernel"]},{"title":"sys_poll","path":"/2025/11/12/sys-poll/","content":"sys_poll （即调用号为7的poll系统调用）是 Linux 中一个非常重要的系统调用，用于检测多个文件描述符，看它们是否准备好去进行某种类型的 IO 操作（比如是否可读、可写等）。它是一种实现 IO 多路复用的高效方法，允许一个程序同时等待多个文件描述符，而不需要为每个文件描述符创建一个单独的线程。 sys_poll 函数原型 int poll(struct pollfd *fds, nfds_t nfds, int timeout); 参数 fds: 指向 struct pollfd 数组的指针，每个元素作为一个结构体描述一个文件描述符及其关心的事件。这个结构体本身被定义为： struct pollfd int fd; // 要监控的文件描述符*short events; //* 关注的事件位掩码*short revents; //* 内核返回的事件位掩码（由系统调用填写）; 其中，events 常常使用宏来填写。这些表示事件的宏定义如下： 宏 值 (16 进制) 说明 POLLIN 0x0001 文件可读（包括普通数据或高优先级数据） POLLPRI 0x0002 高优先级数据可读（例如带外数据） POLLOUT 0x0004 文件可写 POLLERR 0x0008 错误条件发生（系统设置） POLLHUP 0x0010 对端挂断或 FIFO 文件关闭 POLLNVAL 0x0020 文件描述符无效 POLLRDNORM 0x0040 普通数据可读（类似 POLLIN） POLLRDBAND 0x0080 带外优先级数据可读 POLLWRNORM 0x0100 普通可写（类似 POLLOUT） POLLWRBAND 0x0200 带外优先级数据可写 POLLMSG 0x0400 消息可用（主要用于消息队列，POSIX） POLLREMOVE 0x1000 监控对象被移除（内核使用） POLLONESHOT 0x8000 仅触发一次事件，之后自动清除（内核使用） nfds: 传入的数组中元素的数量 timeout: 等待事件的超时时间（毫秒），-1 表示无限等待，0 表示立即返回 返回值 成功时返回发生事件的文件描述符数量（非负整数） 失败时返回 -errno（如 EINVAL, EFAULT, EBADF） 用例 .equ POLLIN, 0x0001 .section .datafds:\t# 定义一个 pollfd 数组，监控文件描述符 0 (stdin) 是否可读\t.long 0 # fd = 0 (stdin)\t.short POLLIN # events = POLLIN (可读事件)\t.short 0x0000 # revents (内核填写，初始为 0)timeout:\t.long 5000 # 等待 5000 毫秒（5 秒）\t.section .text\t.globl _start_start:\t# 调用 sys_poll 监控 stdin 是否有可读事件\tmov $7, %rax # 系统调用号 (7 = sys_poll)\tlea fds(%rip), %rdi # struct pollfd *fds\tmov $1, %rsi # nfds = 1 (数组中只有一个元素)\tlea timeout(%rip), %rdx # timeout = 5000 ms\tsyscall # 执行系统调用\t# 退出程序\tmov $60, %rax # 系统调用号 (60 = sys_exit)\txor %rdi, %rdi # return 0\tsyscall 分析： 上述代码演示了如何使用 sys_poll 监控标准输入（stdin，文件描述符 0）是否可读。 程序首先在 .data 段定义了一个 struct pollfd 数组 fds： fd 字段设为 0，表示标准输入 events 字段设为 POLLIN，表示关注可读事件 revents 字段初始化为 0，系统调用返回时内核会写入实际发生的事件 timeout 字段被设为 5000，表示最多等待 5 秒。由于我们只定义了一个结构体，fds 仅仅是一个指向结构体的指针，而不指向一个数组，所以我们将数组长度nfds 设置为1 。这样一来，运行到第一个syscall 时，系统调用大致上可以等效为： poll(fds, 1, 5000); 程序最后调用 sys_exit 系统调用正常退出，返回值 0 表示成功。 通过这种方式，sys_poll 可以有效地在单线程中同时监控多个 IO 事件，常用于实现事件循环或非阻塞 IO。","tags":["Linux, Kernel"]},{"title":"sys_stat, sys_fstat 以及 sys_lstat","path":"/2025/11/12/sys-stat-sys-fstat-以及-sys-lstat/","content":"sys_stat （调用号为4）、sys_fstat （调用号为5）和 sys_lstat （调用号为6）是 Linux 系统中的三个基本文件状态查询系统调用，用于获取文件的元信息（如大小、权限、时间戳等）。 这三个系统调用虽然都用于获取文件元信息，但三者仍然存在明显的不同。sys_stat 和sys_lstat都是通过文件的路径对文件进行访问的，而sys_fstat 却是通过文件描述符fd 对某一文件进行访问。与sys_stat相比，sys_lstat 虽然也通过文件的路径对文件进行访问，但在处理符号链接的方式上有很大的区别。前者查询到符号链接时，会对其所指向的那个目标文件进行查询；而后者则会对符号链接这个文件本身进行查询，并不会重定向至符号链接所指向的那个文件。 无论是这三者中的哪一个，返回元信息的结构体struct stat 的定义都是一致的。struct stat 被定义为： struct stat dev_t st_dev; /* 文件所在设备号 */ ino_t st_ino; /* 文件 i-node 号 */ nlink_t st_nlink; /* 硬链接数 */ mode_t st_mode; /* 文件类型与权限模式 */ uid_t st_uid; /* 所有者用户 ID */ gid_t st_gid; /* 所有者组 ID */ dev_t st_rdev; /* 特殊文件的设备号（字符/块设备） */ off_t st_size; /* 文件大小（字节数） */ blksize_t st_blksize; /* 文件系统 I/O 块大小 */ blkcnt_t st_blocks; /* 分配的块数 */ /* 时间戳 */ struct timespec st_atim; /* 最后访问时间 */ struct timespec st_mtim; /* 最后修改时间 */ struct timespec st_ctim; /* i-node 状态改变时间 */; sys_stat 函数原型 int stat(const char *pathname, struct stat *statbuf); 参数 pathname: 要查询的文件路径（字符串） statbuf: 指向 struct stat 结构的指针，用于存储文件信息 返回值 成功时返回 0 失败时返回 errno（如 ENOENT, EACCES, ENOTDIR） sys_fstat 函数原型 int fstat(int fd, struct stat *statbuf); 参数 fd: 已打开文件的文件描述符 statbuf: 指向 struct stat 结构的指针，用于存储文件信息 返回值 成功时返回 0 失败时返回 errno（如 EBADF, EFAULT） sys_lstat 函数原型 int lstat(const char *pathname, struct stat *statbuf); 参数 pathname: 要查询的文件路径（字符串） statbuf: 指向 struct stat 结构的指针，用于存储文件信息 返回值 成功时返回 0 失败时返回 errno（如 ENOENT, EACCES, ENOTDIR） 用例 .equ SYS_STAT, 4 # sys_stat 系统调用号\t.equ SYS_FSTAT, 5 # sys_fstat 系统调用号\t.equ SYS_LSTAT, 6 # sys_lstat 系统调用号\t.section .datafilename:\t.ascii /tmp/test.txtstatbuf:\t.space 144 # struct stat 通常为 144 字节（x86-64）\t.section .text\t.globl _start_start:\t# 使用 sys_stat 查询文件状态\tmov $SYS_STAT, %rax\tlea filename(%rip), %rdi\tlea statbuf(%rip), %rsi\tsyscall\t# 使用 sys_fstat 查询已打开文件描述符状态\t# 假设文件描述符保存在 %r8\tmov $SYS_FSTAT, %rax\tmov %r8, %rdi\tlea statbuf(%rip), %rsi\tsyscall\t# 使用 sys_lstat 查询符号链接状态\tmov $SYS_LSTAT, %rax\tlea filename(%rip), %rdi\tlea statbuf(%rip), %rsi\tsyscall\t# 退出\tmov $60, %rax\txor %rdi, %rdi\tsyscall 分析： sys_stat 根据文件路径获取目标文件的状态信息，如果路径是符号链接，它返回链接指向文件的信息。 sys_fstat 直接通过文件描述符获取文件状态，不依赖文件路径。 sys_lstat 类似于 stat，但如果路径是符号链接，它返回链接本身的信息而不是目标文件。 在汇编中，这三个系统调用都通过 %rax 指定系统调用号，文件路径或文件描述符通过 %rdi，struct stat 结构指针通过 %rsi，调用 syscall 指令执行系统调用，返回值存放在 %rax：成功为 0，失败为 -errno。","tags":["Linux, Kernel"]},{"title":"sys_open 与 sys_close","path":"/2025/11/12/sys-open-与-sys-close/","content":"sys_open（即调用号为2的系统调用）与sys_close（即调用号为3的系统调用）是 Linux 中的两个基本系统调用，用于对文件描述符进行相关操作。 sys_open会将被打开的文件路径转换为文件描述符int fd，该描述符可用于后续的读写操作。 sys_open 函数原型 int open(const char * pathname, int flags, mode_t mode); 参数 pathname: 要打开的文件路径（字符串） flags: 打开标志，指定文件的打开方式（具体说明见下） mode: 创建文件时的权限模式（仅在使用O_CREAT时有效）（具体说明见下） 返回值 成功时返回文件描述符（非负整数fd） 失败时返回-errno（如ENOENT, EACCES, EMFILE） sys_close 函数原型 int close(int fd); 参数 fd : 要关闭的文件描述符 返回值 成功时返回0 失败时返回-errno（如EBADF, EINTR, EIO） flags的定义 flags 的赋值通常是由“基本访问模式”与“附加标志”通过或逻辑所附加而来的。在 Linux 的头文件fcntl.h 中，这二者的定义如下： 基本访问模式 宏定义 值 含义 O_RDONLY 0 只读打开 O_WRONLY 1 只写打开 O_RDWR 2 读写打开 附加标志 宏定义 值（八进制） 值（十六进制） 说明 O_CREAT 0000100 0x40 文件不存在则创建 O_EXCL 0000200 0x80 和O_CREAT 一起用，文件存在则失败 O_NOCTTY 0000400 0x100 不把文件作为控制终端 O_TRUNC 0001000 0x200 截断已存在文件为0长度 O_APPEND 0002000 0x400 写操作追加到文件末尾 O_NONBLOCK 0004000 0x800 非阻塞 IO O_NDELAY 0004000 0x800 与O_NONBLOCK相同 O_DSYNC 0010000 0x1000 数据同步写入 O_SYNC 04010000 0x101000 数据+元数据同步写入 O_RSYNC 04010000 0x101000 与O_SYNC相同（兼容） FASYNC 0020000 0x2000 异步通知 O_DIRECT 0040000 0x4000 直接 IO，绕过内核缓存 O_LARGEFILE 00100000 0x8000 大文件支持（32位） O_DIRECTORY 00200000 0x10000 必须是目录，否则出错 O_NOFOLLOW 00400000 0x20000 不跟随符号链接 O_NOATIME 01000000 0x40000 不更新时间戳 O_CLOEXEC 02000000 0x80000 设置FD_CLOEXEC，exec 时关闭 O_PATH 010000000 0x200000 只获取路径引用，不打开文件 O_TMPFILE 020000000 0x400000 创建匿名临时文件（需O_DIRECTORY） O_TMPFILE_MASK 03777700000 - 内部掩码，用于屏蔽O_TMPFILE 上述所有宏在给某一flags 赋值时，使用按位或运算符|进行连接。如： int flags = O_WRONLY | O_CREAT; 该flags 意为：打开文件时采用只写模式；且如果文件不存在，则自动创建之。 可以想到，基本访问模式这三者只能独立存在，不能同时存在于一个表达式中。 权限模式的定义 Unix 系统的权限模式由三个部分所组成：所有者（owner）的权限、所有者所在用户组中的其他用户（group）的权限、非以上用户的其他用户（others）的权限，通过数字进行区分。 Unix 系统的权限主要有三种：读（r）、写（w）、执行（x）。如下： 权限 二进制 八进制 --- 000 0 --x 001 1 -w- 010 2 -wx 011 3 r-- 100 4 r-x 101 5 rw- 110 6 rwx 111 7 其中- 表示用户不具有某一种权限。每一类用户通过八进制数来表示自身的权限。三类用户的排列顺序为：owner-group-others 。 如一个文件对所有用户可读、可写、可执行，那么它的权限模式为： rwxrwxrwx ，亦即0777。 用例 .equ FLAGS, 0x241 # O_WRONLY | O_CREAT | O_TRUNC .section .datafilename:\t.asciz /tmp/test.txt # 要打开的文件路径buffer:\t.ascii Hello from sys_open! \\0\tbuffer_len = . - buffer\t.section .text\t.globl _start_start: # 调用 sys_open 创建/打开文件 mov $2, %rax # 系统调用号 (2 = sys_open) lea filename(%rip), %rdi # const char *pathname = filename mov $FLAGS, %rsi # 通过宏定义给 flags 赋值 mov $0644, %rdx # mode = 0644 (rw-r--r--) syscall # 执行系统调用 # 保存文件描述符 mov %rax, %r8 # 保存文件描述符到 %r8 # 使用 sys_write 向文件写入数据 mov $1, %rax # 系统调用号 (1 = sys_write) mov %r8, %rdi # 使用刚才打开的文件描述符 lea buffer(%rip), %rsi # const void *buf = buffer mov $buffer_len, %rdx # count = buffer_len syscall # 执行系统调用 # 使用 sys_close 关闭文件 mov $3, %rax # 系统调用号 (3 = sys_close) mov %r8, %rdi # 关闭文件描述符 syscall # 执行系统调用 # 退出 mov $60, %rax # 系统调用号 (60 = sys_exit) xor %rdi, %rdi # return 0 syscall 分析： 上述代码演示了如何使用sys_open系统调用创建并打开一个文件进行写入操作。 程序首先定义了要打开的文件路径filename和要写入的数据buffer。在_start标签处，程序将系统调用号2（sys_open）存入%rax寄存器，将文件路径地址加载到%rdi，设置打开标志为0x241（O_WRONLY | O_CREAT | O_TRUNC，表示只写、如不存在则创建、截断为0长度），并设置文件权限为0644。这个操作，用 C 语言来写的话，就是： int fd = open(/tmp/test.txt, O_WRONLY | O_CREAT | O_TRUNC, 0644); 在执行syscall指令后，系统调用会尝试打开指定的这个文件。如果成功，文件描述符会存储在%rax中；如果失败，%rax将包含负值。 成功打开文件后，我们将文件描述符备份到%r8寄存器，以防止在后面调用到其他系统调用时覆盖了原本的文件描述符。然后，我们使用sys_write向该文件中写入我们准备好的数据。最后，程序使用sys_close（系统调用号为3）关闭文件描述符，释放系统资源，并调用sys_exit正常退出。","tags":["Linux, Kernel"]},{"title":"sys_write","path":"/2025/11/12/sys-write/","content":"sys_write（即调用号为1的write系统调用）是 Linux 中的一个基本系统调用，用于向某一文件描述符中写入数据。它从指定的某一内存区域读取数据，并将其写入到目标，返回值为实际写入的字节数。 sys_write 函数原型 ssize_t write(int fd, const void *buf, size_t count); 参数 fd: 文件描述符，即写入的位置所在 buf: 缓冲区指针，要写入的数据来源 count: 要写入多少字节 返回值 成功时返回实际写入的字节数 失败时返回-errno（如EBADF, EPIPE, ENOSPC） 用例 .section .datamessage:\t.ascii Hello, World! msg_len = . - message\t.section .text\t.globl _start_start: # 调用 sys_write 输出消息 mov $1, %rax # 系统调用号 (1 = sys_write) mov $1, %rdi # 文件描述符 (1 = stdout) lea message(%rip), %rsi # 使得 const void * buf = message mov $msg_len, %rdx # count = msg_len (消息长度) syscall # 执行系统调用 # 退出程序 mov $60, %rax # 系统调用号 (60 = sys_exit) xor %rdi, %rdi # return 0 syscall 分析： 上述代码演示了如何使用 sys_write向标准输出（stdout，文件描述符1）写入数据。 程序首先定义了一个字符串message，并计算其长度msg_len。在_start标签处，程序将系统调用号1（sys_write）存入%rax寄存器，将文件描述符1（stdout）存入%rdi，将message的地址加载到%rsi，并设置要写入的字节数为msg_len。亦即： write(1, message, msg_len); 执行syscall指令后，系统调用会将消息数据写入到标准输出，用户可以在终端看到输出的文字。实际写入的字节数会存储在%rax中。 最后，程序调用sys_exit（系统调用号为60）正常退出，返回值为0表示成功执行。","tags":["Linux, Kernel"]},{"title":"sys_read","path":"/2025/11/12/sys-read/","content":"sys_read（即调用号为0的read系统调用）是 Linux 中的一个基本系统调用，用于从文件描述符中读取数据，并存储在一段指定的内存区域中，返回值为读取到的字节数。 sys_read 函数原型 ssize_t read(int fd, void *buf, size_t count); 参数 fd: 文件描述符，即指定读取的“源”之所在 buf: 缓冲区指针，数据将被读取到这里 count: 要读取的最大字节数 返回值 成功时返回实际读取的字节数 返回0表示已到达文件末尾(EOF) 失败时返回-errno（如EINTR, EBADF） 用例 .section .databuffer: .space 128\t.section .text\t.globl _start_start: # 调用 sys_read 读取数据 mov $0, %rax # 系统调用号 (0 = sys_read) mov $0, %rdi # 文件描述符 (0 = stdin) lea buffer(%rip), %rsi # 使得 void * buf = buffer mov $128, %rdx # count = 128 (前面定义 buffer 的长度) syscall # 执行系统调用 # 数据读取完毕，存储在 buffer 中 # 返回值 %rax 为读取的字节长度 mov %rax, %r12 # 备份 %rax 至 %r12 # 调用 sys_write 将刚刚输入的数据打印出来\tmov $1, %rax # 系统调用号 (1 = sys_write) mov $1, %rdi # 文件描述符 (1 = stdout) lea buffer(%rip), %rsi # 使得void * buf = buffer\tmov %r12, %rdx # 使得 sys_write 输出的长度为前面读取的字节长度\tsyscall # 退出程序 mov $60, %rax # 系统调用号 (60 = sys_exit) xor %rdi, %rdi # return 0 syscall 分析： 上述代码演示了如何使用 sys_read系统调用从标准输入（stdin，文件描述符0）读取数据。 程序首先定义了一个128字节的buffer作为存储读取数据的缓冲区。在_start标签处，程序将系统调用号0（sys_read）存入 %rax寄存器，将文件描述符0（stdin）存入%rdi，将buffer的地址加载到%rsi，并设置要读取的最大字节数为128。此即为以下代码所指的调用： read(0, buffer, 128); 执行syscall指令后，系统调用会从标准输入读取用户输入的数据，并将实际读取的字节数存储在%rax中。 随后，程序将返回值（读取的字节数）备份到%r12寄存器，然后准备调用sys_write（系统调用号为1）将读取的数据输出到标准输出（stdout，文件描述符1）。最后，程序调用sys_exit（系统调用号为60）退出，返回值为0表示成功执行。","tags":["Linux, Kernel"]},{"title":"Linux x86_64 系统调用表","path":"/2025/11/12/Linux-x86-64-系统调用表/","content":"说明： 调用号存放在 %rax 前六个参数依次在 %rdi, %rsi, %rdx, %r10, %r8, %r9 返回值存放在 %rax 错误时返回 -1 并设置 errno 系统调用号 名称 函数原型 说明 0 read ssize_t read(int fd, void *buf, size_t count); 此系统调用用于从指定的文件描述符 fd 所代表的设备或文件中读取数据。它将最多 count 字节的数据传输至由 buf 指向的用户空间缓冲区。返回值为实际读取的字节数，若到达文件末尾则返回 0，若发生错误则返回 -1。该调用是一个阻塞式操作，除非文件描述符被设置为非阻塞模式。 1 write ssize_t write(int fd, const void *buf, size_t count); 此系统调用用于将最多 count 字节的数据从用户空间缓冲区 buf 写入由文件描述符 fd 所代表的文件或设备中。返回值为实际写入的字节数，若发生错误则返回 -1。在某些情况下，写入的字节数可能小于请求的 count。 2 open int open(const char *pathname, int flags, mode_t mode); 此系统调用用于打开一个由 pathname 指定的文件，并返回一个可用于后续操作（如 read 或 write）的文件描述符。flags 参数控制打开模式（如只读、只写或读写），mode 参数则在创建新文件时指定其权限。若成功则返回文件描述符，失败则返回 -1。 3 close int close(int fd); 此系统调用用于关闭指定的文件描述符 fd，使其不再引用任何文件，并释放该描述符所关联的系统资源。成功返回 0，失败返回 -1。 4 stat int stat(const char *pathname, struct stat *statbuf); 此系统调用用于获取由 pathname 指定的文件的状态信息，并将其存储在 statbuf 结构体中。这些信息包括文件类型、权限、大小、最后修改时间等。成功返回 0，失败返回 -1。 5 fstat int fstat(int fd, struct stat *statbuf); 此系统调用与 stat 类似，但它通过文件描述符 fd 来获取已打开文件的状态信息。这避免了文件路径解析过程中的潜在竞态条件。成功返回 0，失败返回 -1。 6 lstat int lstat(const char *pathname, struct stat *statbuf); 此系统调用类似于 stat，但如果 pathname 是一个符号链接，它会返回符号链接本身的状态信息，而不是它所指向的文件的状态信息。成功返回 0，失败返回 -1。 7 poll int poll(struct pollfd *fds, nfds_t nfds, int timeout); 此系统调用用于监视一组文件描述符，以等待其中一个或多个描述符准备好进行 IO 操作。它检查每个 pollfd 结构体中的 events，并在相应的 revents 字段中返回就绪事件。timeout 参数指定了等待的毫秒数。返回值为就绪的文件描述符总数，超时返回 0，失败返回 -1。 8 lseek off_t lseek(int fd, off_t offset, int whence); 此系统调用用于重新定位文件描述符 fd 的读写位置。offset 参数指定偏移量，whence 则指定偏移的起始位置（如文件开头 SEEK_SET、当前位置 SEEK_CUR 或文件末尾 SEEK_END）。返回值为新的文件位置，失败返回 -1。 9 mmap void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 此系统调用用于将一个文件或设备的一部分映射到进程的虚拟地址空间。它允许进程像访问内存一样访问文件内容，从而避免了 readwrite 调用带来的开销。成功返回映射区域的起始地址，失败返回 MAP_FAILED。 10 mprotect int mprotect(void *addr, size_t len, int prot); 此系统调用用于修改一个进程内存区域的保护权限。addr 和 len 指定了要修改的内存区域，prot 参数则设置新的权限，如可读、可写或可执行。成功返回 0，失败返回 -1。 11 munmap int munmap(void *addr, size_t length); 此系统调用用于取消进程的虚拟地址空间中的映射。它释放了由 mmap 创建的内存区域，使其不再可访问。成功返回 0，失败返回 -1。 12 brk int brk(void *addr); 此系统调用用于改变进程数据段的结束位置，通常称为 program break。它可以通过调整 brk 的值来动态地分配或释放内存。成功返回 0，失败返回 -1。 13 rt_sigaction int rt_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact, size_t sigsetsize); 此系统调用用于检查或改变与特定信号 signum 相关的处理行为。它是一个更先进和更健壮的信号处理版本，支持实时信号。成功返回 0，失败返回 -1。 14 rt_sigprocmask int rt_sigprocmask(int how, const sigset_t *set, sigset_t *oldset, size_t sigsetsize); 此系统调用用于检查或改变进程的信号阻塞掩码。它可以用于阻塞（SIG_BLOCK）、解除阻塞（SIG_UNBLOCK）或设置（SIG_SETMASK）信号集。成功返回 0，失败返回 -1。 15 rt_sigreturn int rt_sigreturn(void); 此系统调用用于从信号处理函数中返回。它恢复了在进入信号处理函数之前保存的进程上下文，包括寄存器和信号掩码。该调用通常由内核自动生成，而不是由用户直接调用。 16 ioctl int ioctl(int fd, unsigned long request, ...); 此系统调用用于对设备执行特定的 IO 控制操作。fd 是设备的文件描述符，request 指定要执行的操作。其后的参数取决于具体请求。该调用提供了对设备底层功能的访问，如配置终端、调整驱动程序参数等。成功返回 0，失败返回 -1。 17 pread64 ssize_t pread64(int fd, void *buf, size_t count, off64_t offset); 此系统调用用于从指定的文件描述符 fd 中读取数据，但它在 offset 处开始读取，并且不改变文件描述符的当前读写位置。这对于多线程或并发访问同一个文件非常有用。返回值为实际读取的字节数，失败返回 -1。 18 pwrite64 ssize_t pwrite64(int fd, const void *buf, size_t count, off64_t offset); 此系统调用用于向指定的文件描述符 fd 写入数据，但它在 offset 处开始写入，并且不改变文件描述符的当前读写位置。这与 pread64 类似，提供了原子性的写入操作，避免了文件指针的竞争。返回值为实际写入的字节数，失败返回 -1。 19 readv ssize_t readv(int fd, const struct iovec *iov, int iovcnt); 此系统调用执行一个分散读取操作。它从文件描述符 fd 中读取数据，并按顺序将数据分散到由 iov 数组（iovec 结构体）指定的多个缓冲区中。iovcnt 是 iov 数组中元素的数量。返回值为读取的总字节数，失败返回 -1。 20 writev ssize_t writev(int fd, const struct iovec *iov, int iovcnt); 此系统调用执行一个集中写入操作。它将由 iov 数组（iovec 结构体）指定的多个缓冲区中的数据，按顺序集中写入到文件描述符 fd 中。iovcnt 是 iov 数组中元素的数量。返回值为写入的总字节数，失败返回 -1。 21 access int access(const char *pathname, int mode); 此系统调用用于检查调用进程是否具有对 pathname 指定的文件或目录的访问权限。mode 参数指定要检查的权限类型，如 R_OK（可读）、W_OK（可写）、X_OK（可执行）或 F_OK（文件存在）。成功返回 0，失败返回 -1。 22 pipe int pipe(int pipefd[2]); 此系统调用用于创建一个简单的管道，用于进程间的通信。它创建两个文件描述符，pipefd[0] 用于读取，pipefd[1] 用于写入。写入 pipefd[1] 的数据可以从 pipefd[0] 中读取。成功返回 0，失败返回 -1。 23 select int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 此系统调用用于监视多个文件描述符集，以等待其中任何一个描述符准备好进行 IO 操作。它能够同时监视可读、可写和异常情况。返回值为就绪的文件描述符总数，超时返回 0，失败返回 -1。 24 sched_yield int sched_yield(void); 此系统调用用于自愿地放弃 CPU，允许其他具有相同或更高优先级的线程或进程运行。它将调用进程从运行队列中移到就绪队列的末尾。成功返回 0，失败返回 -1。 25 mremap void *mremap(void *old_address, size_t old_size, size_t new_size, int flags, ... /* void *new_address */); 此系统调用用于调整现有内存映射的大小。它将 old_address 开始的 old_size 字节内存映射重新映射到 new_size 字节。可以用于扩大或缩小一个内存区域。成功返回新映射的起始地址，失败返回 MAP_FAILED。 26 msync int msync(void *addr, size_t length, int flags); 此系统调用用于将内存映射区域中的修改数据同步到文件。它确保对内存中的更改被写入到底层文件系统，从而保持文件和内存的同步。成功返回 0，失败返回 -1。 27 mincore int mincore(void *addr, size_t length, unsigned char *vec); 此系统调用用于确定虚拟内存区域的哪些页面当前位于物理内存（RAM）中。它将结果存储在 vec 数组中，其中每个字节对应一个页面。成功返回 0，失败返回 -1。 28 madvise int madvise(void *addr, size_t length, int advice); 此系统调用用于告知内核如何处理一个进程的内存区域。advice 参数可以提供关于未来内存访问模式的建议，例如 MADV_SEQUENTIAL（按顺序访问）或 MADV_WILLNEED（即将访问），从而帮助内核进行性能优化。成功返回 0，失败返回 -1。 29 shmget int shmget(key_t key, size_t size, int shmflg); 此系统调用用于创建一个新的共享内存段或获取一个已有的共享内存段。key 用于标识共享内存段，size 指定段的大小，shmflg 则控制创建标志和权限。成功返回共享内存标识符，失败返回 -1。 30 shmat void *shmat(int shmid, const void *shmaddr, int shmflg); 此系统调用用于将由 shmid 标识的共享内存段附加到调用进程的地址空间。shmaddr 可用于指定附加地址，如果为 NULL 则由内核选择。成功返回附加的地址，失败返回 -1。 31 shmctl int shmctl(int shmid, int cmd, struct shmid_ds *buf); 此系统调用用于对由 shmid 标识的共享内存段执行控制操作。cmd 参数指定要执行的操作，例如删除共享内存段（IPC_RMID）或获取状态信息（IPC_STAT）。成功返回 0，失败返回 -1。 32 dup int dup(int oldfd); 此系统调用用于创建一个新的文件描述符，它是 oldfd 的一个副本。新的文件描述符指向与 oldfd 相同的底层文件或设备，并且共享文件指针、文件状态标志等。返回值为新的文件描述符，失败返回 -1。 33 dup2 int dup2(int oldfd, int newfd); 此系统调用用于将 newfd 重定向为 oldfd 的副本。如果 newfd 已经打开，它会先被关闭。此操作是原子性的。dup2 是一个常用的技巧，例如用于重定向标准输入输出。成功返回 newfd，失败返回 -1。 34 pause int pause(void); 此系统调用用于使调用进程进入睡眠状态，直到接收到一个信号为止。它不会返回，除非信号处理函数返回，或者进程被一个未被忽略的信号终止。返回值为 -1 并设置 errno 为 EINTR。 35 nanosleep int nanosleep(const struct timespec *req, struct timespec *rem); 此系统调用用于让调用进程精确地暂停指定的纳秒级时间。req 指定请求的睡眠时间，rem 可用于获取剩余的睡眠时间，如果调用被信号中断。成功返回 0，被信号中断返回 -1。 36 getitimer int getitimer(int which, struct itimerval *curr_value); 此系统调用用于获取指定间隔定时器的当前值。which 参数指定定时器的类型，例如 ITIMER_REAL（实时定时器）。当前值被存储在 curr_value 结构体中。成功返回 0，失败返回 -1。 37 alarm unsigned int alarm(unsigned int seconds); 此系统调用用于设置一个定时器，在指定的 seconds 秒后向调用进程发送 SIGALRM 信号。如果 seconds 为 0，则取消任何待定的定时器。返回值为前一个定时器剩余的秒数。 38 setitimer int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); 此系统调用用于设置或修改指定的间隔定时器。which 指定定时器类型，new_value 设置新的值，而 old_value 则可选地用于获取前一个值。成功返回 0，失败返回 -1。 39 getpid pid_t getpid(void); 此系统调用用于获取调用进程的进程 ID。该 ID 在系统范围内是唯一的。返回值为进程 ID。 40 sendfile ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); 此系统调用用于在两个文件描述符之间零拷贝地传输数据。它直接从 in_fd 传输最多 count 字节数据到 out_fd，无需通过用户空间缓冲区。这对于高效地传输文件内容非常有用。返回值为实际传输的字节数，失败返回 -1。 41 socket int socket(int domain, int type, int protocol); 此系统调用用于创建一个新的套接字。domain 参数指定协议族（如 AF_INET 用于 IPv4），type 指定套接字类型（如 SOCK_STREAM 用于 TCP），protocol 通常为 0。成功返回新的套接字文件描述符，失败返回 -1。 42 connect int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 此系统调用用于将一个套接字连接到指定的网络地址 addr。这通常用于客户端程序建立与服务器的连接。成功返回 0，失败返回 -1。 43 accept int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 此系统调用用于接受一个传入的连接请求。它从监听套接字 sockfd 的队列中取出一个连接，并创建一个新的已连接套接字。新套接字的文件描述符被返回，可用于与客户端通信。成功返回新的文件描述符，失败返回 -1。 44 sendto ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); 此系统调用用于在无连接的套接字（如 UDP）上发送数据。它将 buf 中的数据发送到由 dest_addr 指定的目标地址。返回值为发送的字节数，失败返回 -1。 45 recvfrom ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); 此系统调用用于在无连接的套接字（如 UDP）上接收数据。它从套接字 sockfd 中读取数据并将其存储在 buf 中，同时将发送方的地址信息存储在 src_addr 中。返回值为接收的字节数，失败返回 -1。 46 sendmsg ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); 此系统调用提供了比 sendto 更通用的数据发送方式。它通过 msghdr 结构体，可以发送多个不连续的缓冲区，并支持发送辅助数据（如文件描述符）。返回值为发送的字节数，失败返回 -1。 47 recvmsg ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); 此系统调用提供了比 recvfrom 更通用的数据接收方式。它通过 msghdr 结构体，可以接收多个不连续的缓冲区，并支持接收辅助数据。返回值为接收的字节数，失败返回 -1。 48 shutdown int shutdown(int sockfd, int how); 此系统调用用于部分或完全关闭一个套接字的连接。how 参数控制关闭方向：SHUT_RD（禁止后续读取）、SHUT_WR（禁止后续写入）或 SHUT_RDWR（禁止读写）。成功返回 0，失败返回 -1。 49 bind int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 此系统调用用于将一个套接字与一个特定的本地地址（如 IP 地址和端口号）关联起来。这通常用于服务器程序，以便监听该地址上的传入连接。成功返回 0，失败返回 -1。 50 listen int listen(int sockfd, int backlog); 此系统调用用于将一个套接字设置为被动模式，以便接受传入的连接。backlog 参数指定了等待接受的连接请求队列的最大长度。成功返回 0，失败返回 -1。 51 getsockname int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 此系统调用用于获取指定套接字 sockfd 的本地地址信息。地址信息被存储在 addr 中。成功返回 0，失败返回 -1。 52 getpeername int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 此系统调用用于获取与指定套接字 sockfd 连接的对端（peer）的地址信息。地址信息被存储在 addr 中。成功返回 0，失败返回 -1。 53 socketpair int socketpair(int domain, int type, int protocol, int sv[2]); 此系统调用用于创建一对相互连接的无名套接字。sv 数组将包含两个新的文件描述符，它们可以用于双向通信。这通常用于父子进程或同一进程内的线程间通信。成功返回 0，失败返回 -1。 54 setsockopt int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); 此系统调用用于设置套接字选项。level 指定选项的协议层，optname 指定选项名称，optval 和 optlen 提供选项值。例如，可以用来设置套接字为非阻塞模式或启用地址重用。成功返回 0，失败返回 -1。 55 getsockopt int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen); 此系统调用用于获取套接字选项。它与 setsockopt 类似，但用于检索选项的当前值。成功返回 0，失败返回 -1。 56 clone int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...); 此系统调用用于创建一个新的子进程或线程。它比 fork 更灵活，允许调用者精确控制新进程与父进程共享哪些资源，如内存、文件描述符和信号处理程序。成功返回子进程的 PID，失败返回 -1。 57 fork pid_t fork(void); 此系统调用用于创建一个新的子进程，它是调用进程的一个完全独立的副本。子进程与父进程拥有相同的代码、数据和文件描述符副本，但有自己的独立的地址空间。成功返回子进程的 PID（在父进程中），或 0（在子进程中），失败返回 -1。 58 vfork pid_t vfork(void); 此系统调用用于创建一个新的子进程，与 fork 类似，但它在创建后共享父进程的地址空间。父进程会阻塞，直到子进程调用 execve 或 _exit。它主要用于快速创建新进程以执行新程序。返回规则与 fork 相同。 59 execve int execve(const char *pathname, char *const argv[], char *const envp[]); 此系统调用用于在当前进程的上下文中执行一个新的程序。它加载 pathname 指定的可执行文件，并用 argv 和 envp 提供的参数和环境变量替换当前进程的映像。如果成功，它不会返回，如果失败，则返回 -1。 60 exit void exit(int status); 此系统调用用于终止调用进程。status 参数是一个整数，作为进程的退出状态码返回给父进程。它会执行所有必要的清理工作，包括关闭所有文件描述符。此调用永不返回。 61 wait4 pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage); 此系统调用用于等待一个子进程状态的改变（如终止或停止）。它可以等待指定 PID 的子进程，或者任何子进程。它还可以在 rusage 中返回子进程的资源使用情况。成功返回已终止子进程的 PID，失败返回 -1。 62 kill int kill(pid_t pid, int sig); 此系统调用用于向指定的进程或进程组发送信号。pid 指定目标进程，sig 指定要发送的信号。它可以用于终止进程、暂停进程或执行其他信号相关的操作。成功返回 0，失败返回 -1。 63 uname int uname(struct utsname *buf); 此系统调用用于获取当前系统的信息。它将系统名称、版本号、内核版本等信息填充到 utsname 结构体中。成功返回 0，失败返回 -1。 64 semget int semget(key_t key, int nsems, int semflg); 此系统调用用于创建一个新的信号量集或获取一个已有的信号量集。key 用于标识信号量集，nsems 指定信号量的数量，semflg 则控制创建标志和权限。成功返回信号量集标识符，失败返回 -1。 65 semop int semop(int semid, struct sembuf *sops, size_t nsops); 此系统调用用于在由 semid 标识的信号量集上执行原子性的操作。sops 是一个 sembuf 结构体数组，每个结构体定义一个操作。成功返回 0，失败返回 -1。 66 semctl int semctl(int semid, int semnum, int cmd, ...); 此系统调用用于对由 semid 标识的信号量集执行控制操作。cmd 参数指定要执行的操作，例如删除信号量集（IPC_RMID）或设置信号量值（SETVAL）。成功返回 0，失败返回 -1。 67 shmdt int shmdt(const void *shmaddr); 此系统调用用于将由 shmaddr 指定的共享内存段从调用进程的地址空间中分离。它不会删除共享内存段，只是解除进程与其的关联。成功返回 0，失败返回 -1。 68 msgget int msgget(key_t key, int msgflg); 此系统调用用于创建一个新的消息队列或获取一个已有的消息队列。key 用于标识消息队列，msgflg 则控制创建标志和权限。成功返回消息队列标识符，失败返回 -1。 69 msgsnd int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 此系统调用用于将一条消息发送到由 msqid 标识的消息队列。msgp 指向消息数据，msgsz 指定消息大小。成功返回 0，失败返回 -1。 70 msgrcv ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); 此系统调用用于从由 msqid 标识的消息队列中接收一条消息。msgtyp 指定要接收的消息类型。成功返回接收的字节数，失败返回 -1。 71 msgctl int msgctl(int msqid, int cmd, struct msqid_ds *buf); 此系统调用用于对由 msqid 标识的消息队列执行控制操作。cmd 参数指定要执行的操作，例如删除消息队列（IPC_RMID）或获取状态信息（IPC_STAT）。成功返回 0，失败返回 -1。 72 fcntl int fcntl(int fd, int cmd, ... /* arg */); 此系统调用用于对文件描述符 fd 执行控制操作。cmd 参数指定要执行的操作，如复制文件描述符（F_DUPFD）、获取设置文件状态标志（F_GETFLF_SETFL）或管理文件锁。成功返回取决于 cmd 的值，失败返回 -1。 73 flock int flock(int fd, int operation); 此系统调用用于对整个文件应用或移除文件锁。fd 是文件描述符，operation 指定锁的类型（共享锁 LOCK_SH、排他锁 LOCK_EX）或操作（解锁 LOCK_UN）。该锁是建议性锁。成功返回 0，失败返回 -1。 74 fsync int fsync(int fd); 此系统调用用于将文件描述符 fd 所代表的文件所有被修改的缓冲区数据写入底层磁盘，并等待 IO 完成。这确保了数据在系统崩溃时不会丢失。成功返回 0，失败返回 -1。 75 fdatasync int fdatasync(int fd); 此系统调用与 fsync 类似，但它只同步文件数据，不包括元数据（如文件大小或时间戳），除非这些元数据对于后续的数据读取至关重要。这通常比 fsync 更快。成功返回 0，失败返回 -1。 76 truncate int truncate(const char *path, off_t length); 此系统调用用于将由 path 指定的文件截断为指定的 length 字节大小。如果文件大于 length，则多余的数据将被丢弃；如果文件小于 length，则文件将被扩展，扩展的部分将填充零。成功返回 0，失败返回 -1。 77 ftruncate int ftruncate(int fd, off_t length); 此系统调用与 truncate 类似，但它通过文件描述符 fd 来操作已打开的文件。它将文件截断或扩展到指定的 length 字节大小。成功返回 0，失败返回 -1。 78 getdents int getdents(int fd, struct linux_dirent *dirp, unsigned int count); 此系统调用用于读取由文件描述符 fd 指定的目录中的目录项。它将目录项信息填充到 dirp 缓冲区中，最多读取 count 字节。返回值为实际读取的字节数，失败返回 -1。 79 getcwd char *getcwd(char *buf, size_t size); 此系统调用用于获取调用进程的当前工作目录的绝对路径名。路径名被复制到 buf 中，最多 size 字节。成功返回 buf，失败返回 NULL。 80 chdir int chdir(const char *path); 此系统调用用于将调用进程的当前工作目录更改为由 path 指定的目录。成功返回 0，失败返回 -1。 81 fchdir int fchdir(int fd); 此系统调用与 chdir 类似，但它通过文件描述符 fd 来更改当前工作目录。这允许在不指定路径名的情况下更改目录。成功返回 0，失败返回 -1。 82 rename int rename(const char *oldpath, const char *newpath); 此系统调用用于更改文件或目录的名称或位置。它将 oldpath 指定的文件或目录重命名为 newpath。如果 newpath 已经存在，则它会被原子性地替换。成功返回 0，失败返回 -1。 83 mkdir int mkdir(const char *pathname, mode_t mode); 此系统调用用于创建一个新的目录。pathname 指定新目录的路径，mode 则指定新目录的权限。成功返回 0，失败返回 -1。 84 rmdir int rmdir(const char *pathname); 此系统调用用于删除一个空目录。如果目录不为空，则此调用会失败。成功返回 0，失败返回 -1。 85 creat int creat(const char *pathname, mode_t mode); 此系统调用用于创建并打开一个文件。如果文件已经存在，则其内容会被截断为零字节。它等同于 open(pathname, O_CREAT 86 link int link(const char *oldpath, const char *newpath); 此系统调用用于创建一个硬链接。它将 newpath 指向与 oldpath 相同的底层文件。硬链接不能跨越文件系统，也不能链接到目录。成功返回 0，失败返回 -1。 87 unlink int unlink(const char *pathname); 此系统调用用于删除文件系统中的一个名称。如果 pathname 是一个文件的最后一个硬链接，并且没有任何进程打开该文件，那么文件本身将被删除。成功返回 0，失败返回 -1。 88 symlink int symlink(const char *target, const char *linkpath); 此系统调用用于创建一个符号链接（软链接）。它将 linkpath 创建为指向 target 的符号链接。target 可以是文件或目录，并且可以跨越文件系统。成功返回 0，失败返回 -1。 89 readlink ssize_t readlink(const char *pathname, char *buf, size_t bufsiz); 此系统调用用于读取由 pathname 指定的符号链接的值（即它所指向的路径）。它将路径名复制到 buf 中，最多 bufsiz 字节。成功返回读取的字节数，失败返回 -1。 90 chmod int chmod(const char *pathname, mode_t mode); 此系统调用用于改变由 pathname 指定的文件或目录的权限。mode 参数指定新的权限位掩码。成功返回 0，失败返回 -1。 91 fchmod int fchmod(int fd, mode_t mode); 此系统调用与 chmod 类似，但它通过文件描述符 fd 来改变已打开文件的权限。成功返回 0，失败返回 -1。 92 chown int chown(const char *pathname, uid_t owner, gid_t group); 此系统调用用于改变由 pathname 指定的文件或目录的所有者和组。owner 和 group 分别指定新的用户 ID 和组 ID。成功返回 0，失败返回 -1。 93 fchown int fchown(int fd, uid_t owner, gid_t group); 此系统调用与 chown 类似，但它通过文件描述符 fd 来改变已打开文件的所有者和组。成功返回 0，失败返回 -1。 94 lchown int lchown(const char *pathname, uid_t owner, gid_t group); 此系统调用与 chown 类似，但如果 pathname 是一个符号链接，它会改变符号链接本身的所有者和组，而不是它所指向的文件。成功返回 0，失败返回 -1。 95 umask mode_t umask(mode_t mask); 此系统调用用于设置文件创建掩码，并返回旧的掩码。文件创建掩码用于限制新文件和目录的权限。mask 参数中的位在创建文件时会被清零。 96 gettimeofday int gettimeofday(struct timeval *tv, struct timezone *tz); 此系统调用用于获取当前时间和时区信息。tv 结构体中包含秒数和微秒数，tz 结构体（通常被忽略）包含时区信息。成功返回 0，失败返回 -1。 97 getrlimit int getrlimit(int resource, struct rlimit *rlim); 此系统调用用于获取调用进程的资源限制。resource 指定要查询的资源类型，例如 RLIMIT_NOFILE（最大文件描述符数）。rlim 结构体用于存储软限制和硬限制。成功返回 0，失败返回 -1。 98 getrusage int getrusage(int who, struct rusage *usage); 此系统调用用于获取调用进程或其子进程的资源使用情况。who 参数指定要查询的对象，例如 RUSAGE_SELF（当前进程）或 RUSAGE_CHILDREN（已终止的子进程）。usage 结构体用于存储使用情况。成功返回 0，失败返回 -1。 99 sysinfo int sysinfo(struct sysinfo *info); 此系统调用用于获取关于系统整体的统计信息。它将内存、交换空间、进程数等信息填充到 sysinfo 结构体中。成功返回 0，失败返回 -1。 100 times clock_t times(struct tms *buf); 此系统调用用于获取调用进程及其已终止子进程的用户和系统 CPU 时间。这些时间信息被填充到 tms 结构体中。成功返回自某个任意时间点（如系统启动）以来的时钟滴答数，失败返回 (clock_t)-1。 101 ptrace long ptrace(enum ptrace_request request, pid_t pid, void *addr, void *data); 此系统调用为进程提供了对另一个进程（跟踪对象）的控制。它允许一个进程检查和修改另一个进程的内存和寄存器，并控制其执行。这通常用于实现调试器和跟踪工具。成功返回取决于 request 的值，失败返回 -1。 102 getuid uid_t getuid(void); 此系统调用用于获取调用进程的实际用户 ID。返回值为实际用户 ID。 103 syslog int syslog(int type, char *bufp, int len); 此系统调用用于与内核日志缓冲区进行交互。它可以用于读取、清空或控制内核日志。返回值为读取的字节数，或取决于 type 的值，失败返回 -1。 104 getgid gid_t getgid(void); 此系统调用用于获取调用进程的实际组 ID。返回值为实际组 ID。 105 setuid int setuid(uid_t uid); 此系统调用用于设置调用进程的实际用户 ID、有效用户 ID 和保存的用户 ID。如果进程具有适当的权限，它可以用于更改其身份。成功返回 0，失败返回 -1。 106 setgid int setgid(gid_t gid); 此系统调用用于设置调用进程的实际组 ID、有效组 ID 和保存的组 ID。如果进程具有适当的权限，它可以用于更改其组身份。成功返回 0，失败返回 -1。 107 geteuid uid_t geteuid(void); 此系统调用用于获取调用进程的有效用户 ID。有效用户 ID 用于确定文件访问权限。返回值为有效用户 ID。 108 getegid gid_t getegid(void); 此系统调用用于获取调用进程的有效组 ID。有效组 ID 用于确定文件访问权限。返回值为有效组 ID。 109 setpgid int setpgid(pid_t pid, pid_t pgid); 此系统调用用于设置指定进程的进程组 ID。pid 指定目标进程，pgid 指定新的进程组 ID。成功返回 0，失败返回 -1。 110 getppid pid_t getppid(void); 此系统调用用于获取调用进程的父进程 ID。返回值为父进程 ID。 111 getpgrp pid_t getpgrp(void); 此系统调用用于获取调用进程的进程组 ID。返回值为进程组 ID。 112 setsid pid_t setsid(void); 此系统调用用于创建一个新的会话。调用进程成为新会话的会话领导者，并成为一个新的进程组的领导者。此调用通常用于创建守护进程。成功返回新的会话 ID，失败返回 -1。 113 setreuid int setreuid(uid_t ruid, uid_t euid); 此系统调用用于设置调用进程的实际和有效用户 ID。ruid 设置实际用户 ID，euid 设置有效用户 ID。成功返回 0，失败返回 -1。 114 setregid int setregid(gid_t rgid, gid_t egid); 此系统调用用于设置调用进程的实际和有效组 ID。rgid 设置实际组 ID，egid 设置有效组 ID。成功返回 0，失败返回 -1。 115 getgroups int getgroups(int gidsetsize, gid_t grouplist[]); 此系统调用用于获取调用进程的附加组 ID 列表。它将这些 ID 存储在 grouplist 数组中，最多 gidsetsize 个。返回值为实际获取的组 ID 数量，失败返回 -1。 116 setgroups int setgroups(size_t gidsetsize, const gid_t *grouplist); 此系统调用用于设置调用进程的附加组 ID 列表。它将列表设置为由 grouplist 指向的数组，其中包含 gidsetsize 个 ID。成功返回 0，失败返回 -1。 117 setresuid int setresuid(uid_t ruid, uid_t euid, uid_t suid); 此系统调用用于设置调用进程的实际、有效和保存的用户 ID。ruid、euid 和 suid 分别指定新的 ID。成功返回 0，失败返回 -1。 118 getresuid int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid); 此系统调用用于获取调用进程的实际、有效和保存的用户 ID，并将它们存储在相应的指针指向的变量中。成功返回 0，失败返回 -1。 119 setresgid int setresgid(gid_t rgid, gid_t egid, gid_t sgid); 此系统调用用于设置调用进程的实际、有效和保存的组 ID。rgid、egid 和 sgid 分别指定新的 ID。成功返回 0，失败返回 -1。 120 getresgid int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid); 此系统调用用于获取调用进程的实际、有效和保存的组 ID，并将它们存储在相应的指针指向的变量中。成功返回 0，失败返回 -1。 121 getpgid pid_t getpgid(pid_t pid); 此系统调用用于获取指定进程 pid 的进程组 ID。如果 pid 为 0，则获取调用进程的进程组 ID。返回值为进程组 ID，失败返回 -1。 122 setfsuid int setfsuid(uid_t fsuid); 此系统调用用于设置调用进程的文件系统用户 ID。文件系统用户 ID 用于在文件系统操作时检查权限。它通常与有效用户 ID 相同。成功返回旧的文件系统用户 ID，失败返回 -1。 123 setfsgid int setfsgid(gid_t fsgid); 此系统调用用于设置调用进程的文件系统组 ID。文件系统组 ID 用于在文件系统操作时检查权限。它通常与有效组 ID 相同。成功返回旧的文件系统组 ID，失败返回 -1。 124 getsid pid_t getsid(pid_t pid); 此系统调用用于获取指定进程 pid 的会话 ID。如果 pid 为 0，则获取调用进程的会话 ID。返回值为会话 ID，失败返回 -1。 125 capget int capget(cap_user_header_t header, cap_user_data_t data); 此系统调用用于获取调用线程或指定线程的能力。header 结构体提供版本信息，data 结构体用于存储获取的能力位掩码。成功返回 0，失败返回 -1。 126 capset int capset(cap_user_header_t header, const cap_user_data_t data); 此系统调用用于设置调用线程或指定线程的能力。header 结构体提供版本信息，data 结构体用于指定要设置的能力位掩码。成功返回 0，失败返回 -1。 127 rt_sigpending int rt_sigpending(sigset_t *set, size_t sigsetsize); 此系统调用用于获取当前挂起的、被阻塞的信号集合。set 结构体用于存储这些信号。成功返回 0，失败返回 -1。 128 rt_sigtimedwait int rt_sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout, size_t sigsetsize); 此系统调用用于等待 set 集合中的任何信号传递。如果一个信号被接收，该调用会返回，信号信息存储在 info 中。timeout 参数指定等待的超时时间。成功返回信号编号，失败返回 -1。 129 rt_sigqueueinfo int rt_sigqueueinfo(pid_t pid, int sig, siginfo_t *uinfo); 此系统调用用于向指定的进程 pid 发送一个信号 sig，并传递一个 siginfo_t 结构体。这允许在信号中携带额外的信息。成功返回 0，失败返回 -1。 130 rt_sigsuspend int rt_sigsuspend(const sigset_t *set, size_t sigsetsize); 此系统调用用于临时替换进程的信号掩码，并使进程进入睡眠状态，直到接收到一个未被阻塞的信号。成功时，此调用永远不会返回。如果被信号中断，它返回 -1 并设置 errno 为 EINTR。 131 sigaltstack int sigaltstack(const stack_t *ss, stack_t *old_ss); 此系统调用用于设置或获取信号处理程序的备用栈。这可以用于处理 SIGSEGV 或 SIGBUS 等信号，以避免在主栈上处理信号时出现栈溢出。成功返回 0，失败返回 -1。 132 utime int utime(const char *filename, const struct utimbuf *times); 此系统调用用于改变指定文件 filename 的访问和修改时间。times 结构体包含了新的访问时间和修改时间。如果 times 为 NULL，则时间将被设置为当前时间。成功返回 0，失败返回 -1。 133 mknod int mknod(const char *pathname, mode_t mode, dev_t dev); 此系统调用用于在文件系统上创建一个特殊文件。pathname 指定路径，mode 指定文件类型和权限，dev 用于设备文件。成功返回 0，失败返回 -1。 134 uselib int uselib(const char *library); 此系统调用用于加载共享库。它已经被弃用，不再推荐使用。 135 personality int personality(unsigned long persona); 此系统调用用于获取或设置调用进程的执行域（personality）。执行域会影响某些系统调用的行为，例如 fork 和 execve。成功返回旧的 persona 值，失败返回 -1。 136 ustat int ustat(dev_t dev, struct ustat *ubuf); 此系统调用用于获取一个挂载文件系统的统计信息。dev 指定设备号，ubuf 结构体用于存储可用块数和可用节点数等信息。此调用已被弃用，推荐使用 statfs 或 fstatfs。成功返回 0，失败返回 -1。 137 statfs int statfs(const char *path, struct statfs *buf); 此系统调用用于获取包含 path 的文件系统的统计信息。buf 结构体用于存储文件系统类型、总块数、空闲块数等信息。成功返回 0，失败返回 -1。 138 fstatfs int fstatfs(int fd, struct statfs *buf); 此系统调用与 statfs 类似，但它通过文件描述符 fd 来获取文件系统的统计信息。成功返回 0，失败返回 -1。 139 sysfs int sysfs(int option, ...); 此系统调用用于获取或设置内核的 sysfs 文件系统相关信息。它主要用于获取文件系统的类型或挂载点信息。此调用已被弃用。成功返回 0，失败返回 -1。 140 getpriority int getpriority(int which, id_t who); 此系统调用用于获取进程、进程组或用户优先级。which 指定要查询的对象类型，who 指定其 ID。返回值为优先级值，失败返回 -1。 141 setpriority int setpriority(int which, id_t who, int prio); 此系统调用用于设置进程、进程组或用户优先级。prio 参数指定新的优先级值。成功返回 0，失败返回 -1。 142 sched_setparam int sched_setparam(pid_t pid, const struct sched_param *param); 此系统调用用于设置指定进程的调度参数。pid 指定目标进程，param 结构体包含了调度参数（如优先级）。成功返回 0，失败返回 -1。 143 sched_getparam int sched_getparam(pid_t pid, struct sched_param *param); 此系统调用用于获取指定进程的调度参数。param 结构体用于存储获取的参数。成功返回 0，失败返回 -1。 144 sched_setscheduler int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param); 此系统调用用于设置指定进程的调度策略和参数。policy 指定调度策略，如 SCHED_FIFO 或 SCHED_RR。成功返回 0，失败返回 -1。 145 sched_getscheduler int sched_getscheduler(pid_t pid); 此系统调用用于获取指定进程的调度策略。返回值为调度策略（如 SCHED_FIFO 或 SCHED_RR），失败返回 -1。 146 sched_get_priority_max int sched_get_priority_max(int policy); 此系统调用用于获取指定调度策略的最高优先级值。返回值为最高优先级值，失败返回 -1。 147 sched_get_priority_min int sched_get_priority_min(int policy); 此系统调用用于获取指定调度策略的最低优先级值。返回值为最低优先级值，失败返回 -1。 148 sched_rr_get_interval int sched_rr_get_interval(pid_t pid, struct timespec *tp); 此系统调用用于获取指定进程的 SCHED_RR 调度策略的时间片（time slice）间隔。tp 结构体用于存储该间隔。成功返回 0，失败返回 -1。 149 mlock int mlock(const void *addr, size_t len); 此系统调用用于将指定内存区域锁定在物理内存中。这可以防止该区域被换出到交换空间，对于需要实时性能的应用非常有用。成功返回 0，失败返回 -1。 150 munlock int munlock(const void *addr, size_t len); 此系统调用用于解除对指定内存区域的锁定，允许其被换出到交换空间。成功返回 0，失败返回 -1。 151 mlockall int mlockall(int flags); 此系统调用用于锁定调用进程的所有当前和未来的内存。flags 参数控制锁定范围，例如 MCL_CURRENT（当前内存）和 MCL_FUTURE（未来内存）。成功返回 0，失败返回 -1。 152 munlockall int munlockall(void); 此系统调用用于解除对调用进程所有内存的锁定。成功返回 0，失败返回 -1。 153 vhangup int vhangup(void); 此系统调用用于模拟虚拟终端的挂断操作，从而关闭所有与当前虚拟终端相关的终端设备。这主要由 init 进程用于系统重启。成功返回 0，失败返回 -1。 154 modify_ldt int modify_ldt(int func, void *ptr, unsigned long bytecount); 此系统调用用于修改本地描述符表（LDT）。func 指定操作类型（如读或写），ptr 指向数据，bytecount 指定字节数。此调用通常由 C 库使用，不应由普通应用程序直接调用。成功返回 0，失败返回 -1。 155 pivot_root int pivot_root(const char *new_root, const char *put_old); 此系统调用用于改变进程的根文件系统。它将当前根文件系统移动到 put_old，并将 new_root 设置为新的根文件系统。成功返回 0，失败返回 -1。 156 _sysctl int _sysctl(struct __sysctl_args *args); 此系统调用用于在运行时配置内核参数。它通过 __sysctl_args 结构体来指定要操作的参数。此调用已被弃用，推荐使用 /proc/sys 文件系统。成功返回 0，失败返回 -1。 157 prctl int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); 此系统调用用于对调用进程执行特定的操作。option 指定操作类型，例如设置进程的名称（PR_SET_NAME）或控制其能力。返回值为 option 相关的结果，失败返回 -1。 158 arch_prctl int arch_prctl(int code, unsigned long addr); 此系统调用用于对进程执行特定于架构的操作。code 指定操作类型，例如设置 fs 或 gs 段寄存器的基址。成功返回 0，失败返回 -1。 159 adjtimex int adjtimex(struct timex *buf); 此系统调用用于调整系统时钟。timex 结构体包含了用于调整时钟频率和相位的参数。这通常用于实现 NTP（网络时间协议）守护进程。成功返回 0，失败返回 -1。 160 setrlimit int setrlimit(int resource, const struct rlimit *rlim); 此系统调用用于设置调用进程的资源限制。resource 指定要修改的资源类型，rlim 结构体包含新的软限制和硬限制。成功返回 0，失败返回 -1。 161 chroot int chroot(const char *path); 此系统调用用于改变调用进程的根目录。这有效地将进程及其子进程限制在由 path 指定的目录子树中。需要超级用户权限。成功返回 0，失败返回 -1。 162 sync void sync(void); 此系统调用用于将所有文件系统缓存数据写入底层磁盘。它启动同步操作，但不会等待 IO 完成。 163 acct int acct(const char *filename); 此系统调用用于启用或禁用进程会计。当启用时，内核会为每个终止的进程写入一个记录。filename 指定会计文件的路径。成功返回 0，失败返回 -1。 164 settimeofday int settimeofday(const struct timeval *tv, const struct timezone *tz); 此系统调用用于设置系统时间和时区。tv 结构体包含了新的时间，tz 结构体包含了新的时区信息。需要适当的权限。成功返回 0，失败返回 -1。 165 mount int mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *data); 此系统调用用于将一个文件系统挂载到指定位置。source 指定设备或文件，target 指定挂载点，filesystemtype 指定文件系统类型。成功返回 0，失败返回 -1。 166 umount2 int umount2(const char *target, int flags); 此系统调用用于卸载一个文件系统。target 指定挂载点。flags 参数提供了额外的卸载选项，如延迟卸载（MNT_DETACH）。成功返回 0，失败返回 -1。 167 swapon int swapon(const char *path, int swapflags); 此系统调用用于启用一个交换设备或文件。path 指定交换设备的路径，swapflags 提供选项。成功返回 0，失败返回 -1。 168 swapoff int swapoff(const char *path); 此系统调用用于禁用一个交换设备或文件。path 指定交换设备的路径。成功返回 0，失败返回 -1。 169 reboot int reboot(int magic, int magic2, int cmd, void *arg); 此系统调用用于重启、关闭或挂起系统。magic 和 magic2 是特定的魔术数字，cmd 指定要执行的操作（如 LINUX_REBOOT_CMD_RESTART）。需要适当的权限。成功后永不返回，失败返回 -1。 170 sethostname int sethostname(const char *name, size_t len); 此系统调用用于设置系统的主机名。name 指向新的主机名，len 是其长度。需要适当的权限。成功返回 0，失败返回 -1。 171 setdomainname int setdomainname(const char *name, size_t len); 此系统调用用于设置系统的域名。name 指向新的域名，len 是其长度。需要适当的权限。成功返回 0，失败返回 -1。 172 iopl int iopl(int level); 此系统调用用于改变调用进程的 IO 特权级别。level 指定新的特权级别。此调用仅在 x86 架构上可用，且需要适当的权限。成功返回 0，失败返回 -1。 173 ioperm int ioperm(unsigned long from, unsigned long num, int turn_on); 此系统调用用于设置或移除对 IO 端口的访问权限。from 和 num 指定 IO 端口的范围，turn_on 控制是启用还是禁用权限。此调用仅在 x86 架构上可用，且需要适当的权限。成功返回 0，失败返回 -1。 174 create_module int create_module(const char *name, size_t size); 此系统调用用于在内核中创建一个空的模块空间。此调用已被弃用，推荐使用 init_module。 175 init_module int init_module(const void *module_image, unsigned long len, const char *param_values); 此系统调用用于将一个内核模块加载到内核。module_image 指向模块的二进制映像，len 是其大小，param_values 是模块参数。需要适当的权限。成功返回 0，失败返回 -1。 176 delete_module int delete_module(const char *name, unsigned int flags); 此系统调用用于从内核中移除一个已加载的模块。name 指定模块名称，flags 提供卸载选项。需要适当的权限。成功返回 0，失败返回 -1。 177 get_kernel_syms int get_kernel_syms(struct kernel_sym *table); 此系统调用用于获取内核符号表。此调用已被弃用，推荐使用 /proc/kallsyms。 178 query_module int query_module(const char *name, int what, void *buf, size_t bufsize, size_t *ret); 此系统调用用于查询内核模块的信息。此调用已被弃用。 179 quotactl int quotactl(int cmd, const char *special, qid_t id, void *addr); 此系统调用用于管理文件系统配额。cmd 指定操作，special 是设备名称，id 是用户或组 ID。成功返回 0，失败返回 -1。 180 nfsservctl long nfsservctl(int cmd, struct nfsctl_arg *argp, union nfsctl_res *resp); 此系统调用用于控制 NFS 服务器。此调用已被弃用。 181 getpmsg int getpmsg(void); 此系统调用是与流（stream）相关的系统调用，已过时。 182 putpmsg int putpmsg(void); 此系统调用是与流（stream）相关的系统调用，已过时。 183 afs_syscall int afs_syscall(void); 此系统调用是 AFS（Andrew File System）专用的，用于执行特定于 AFS 的操作。 184 tuxcall int tuxcall(void); 此系统调用是 TUX 网络服务器专用的。 185 security int security(void); 此系统调用用于与 Linux 安全模块（LSM）进行交互。它已过时，相关功能已集成到其他系统调用中。 186 gettid pid_t gettid(void); 此系统调用用于获取调用线程的线程 ID（TID）。线程 ID 在系统范围内是唯一的，但与进程 ID（PID）不同。返回值为线程 ID。 187 readahead ssize_t readahead(int fd, off64_t offset, size_t count); 此系统调用用于预读文件数据到页面缓存中。它从文件描述符 fd 的 offset 处开始，预读 count 字节数据。这可以帮助减少后续 read 调用的延迟。成功返回 0，失败返回 -1。 188 setxattr int setxattr(const char *path, const char *name, const void *value, size_t size, int flags); 此系统调用用于设置文件或目录的扩展属性。path 指定文件，name 指定属性名，value 和 size 指定属性值。flags 提供选项，如 XATTR_CREATE（只在属性不存在时创建）。成功返回 0，失败返回 -1。 189 lsetxattr int lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags); 此系统调用与 setxattr 类似，但如果 path 是一个符号链接，它会改变符号链接本身的扩展属性，而不是它所指向的文件。成功返回 0，失败返回 -1。 190 fsetxattr int fsetxattr(int fd, const char *name, const void *value, size_t size, int flags); 此系统调用与 setxattr 类似，但它通过文件描述符 fd 来设置已打开文件的扩展属性。成功返回 0，失败返回 -1。 191 getxattr ssize_t getxattr(const char *path, const char *name, void *value, size_t size); 此系统调用用于获取文件或目录的扩展属性值。path 指定文件，name 指定属性名。属性值被复制到 value 缓冲区中，最多 size 字节。返回值为属性值的大小，失败返回 -1。 192 lgetxattr ssize_t lgetxattr(const char *path, const char *name, void *value, size_t size); 此系统调用与 getxattr 类似，但如果 path 是一个符号链接，它会获取符号链接本身的扩展属性。返回值为属性值的大小，失败返回 -1。 193 fgetxattr ssize_t fgetxattr(int fd, const char *name, void *value, size_t size); 此系统调用与 getxattr 类似，但它通过文件描述符 fd 来获取已打开文件的扩展属性值。返回值为属性值的大小，失败返回 -1。 194 listxattr ssize_t listxattr(const char *path, char *list, size_t size); 此系统调用用于获取文件或目录所有扩展属性的名称列表。属性名被复制到 list 缓冲区中，以空字符分隔。返回值为列表的总大小，失败返回 -1。 195 llistxattr ssize_t llistxattr(const char *path, char *list, size_t size); 此系统调用与 listxattr 类似，但如果 path 是一个符号链接，它会获取符号链接本身的扩展属性名称列表。返回值为列表的总大小，失败返回 -1。 196 flistxattr ssize_t flistxattr(int fd, char *list, size_t size); 此系统调用与 listxattr 类似，但它通过文件描述符 fd 来获取已打开文件的扩展属性名称列表。返回值为列表的总大小，失败返回 -1。 197 removexattr int removexattr(const char *path, const char *name); 此系统调用用于移除文件或目录的扩展属性。path 指定文件，name 指定要移除的属性名。成功返回 0，失败返回 -1。 198 lremovexattr int lremovexattr(const char *path, const char *name); 此系统调用与 removexattr 类似，但如果 path 是一个符号链接，它会移除符号链接本身的扩展属性。成功返回 0，失败返回 -1。 199 fremovexattr int fremovexattr(int fd, const char *name); 此系统调用与 removexattr 类似，但它通过文件描述符 fd 来移除已打开文件的扩展属性。成功返回 0，失败返回 -1。 200 tkill int tkill(int tid, int sig); 此系统调用用于向指定的线程 tid 发送信号。它比 kill 更精确，因为它直接针对单个线程。此调用已被弃用，推荐使用 tgkill。成功返回 0，失败返回 -1。 201 time time_t time(time_t *tloc); 此系统调用用于获取自 Epoch（1970-01-01 00:00:00 +0000 (UTC)）以来的秒数。如果 tloc 非空，则该值也会存储在 tloc 中。返回值为秒数，失败返回 (time_t)-1。 202 futex int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3); 此系统调用用于实现用户空间的快速互斥锁（fast user-space mutexes）。它在用户空间提供原子操作，并且只在必要时才调用内核。futex_op 指定操作类型，如等待（FUTEX_WAIT）或唤醒（FUTEX_WAKE）。成功返回取决于操作类型，失败返回 -1。 203 sched_setaffinity int sched_setaffinity(pid_t pid, size_t cpusize, cpu_set_t *mask); 此系统调用用于设置指定进程的 CPU 亲和力掩码。mask 指定进程可以在哪些 CPU 上运行。成功返回 0，失败返回 -1。 204 sched_getaffinity int sched_getaffinity(pid_t pid, size_t cpusize, cpu_set_t *mask); 此系统调用用于获取指定进程的 CPU 亲和力掩码。mask 结构体用于存储该掩码。成功返回 0，失败返回 -1。 205 set_thread_area int set_thread_area(struct user_desc *u_info); 此系统调用用于设置线程的本地存储（TLS）区域。它用于实现线程局部变量。此调用仅在 x86 架构上可用。成功返回 0，失败返回 -1。 206 io_setup int io_setup(unsigned nr_events, aio_context_t *ctxp); 此系统调用用于设置异步 IO 上下文。nr_events 指定队列中的最大事件数，ctxp 用于存储上下文句柄。成功返回 0，失败返回 -1。 207 io_destroy int io_destroy(aio_context_t ctx); 此系统调用用于销毁指定的异步 IO 上下文。成功返回 0，失败返回 -1。 208 io_getevents int io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout); 此系统调用用于从异步 IO 上下文中检索已完成的事件。events 结构体用于存储事件信息。返回值为获取的事件数，失败返回 -1。 209 io_submit int io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp); 此系统调用用于向异步 IO 上下文提交 IO 请求。iocbpp 是指向 iocb 结构体指针数组的指针，每个结构体描述一个 IO 操作。返回值为提交的请求数，失败返回 -1。 210 io_cancel int io_cancel(aio_context_t ctx_id, struct iocb *iocb, struct io_event *result); 此系统调用用于取消一个已提交的异步 IO 请求。iocb 结构体指定要取消的请求。成功返回 0，失败返回 -1。 211 get_thread_area int get_thread_area(struct user_desc *u_info); 此系统调用用于获取线程的本地存储（TLS）区域。它用于获取由 set_thread_area 设置的信息。成功返回 0，失败返回 -1。 212 lookup_dcookie int lookup_dcookie(u64 cookie, char *buffer, size_t len); 此系统调用用于将一个目录 “cookie” 转换为其路径名。cookie 是一个内核内部标识符。成功返回路径名的长度，失败返回 -1。 213 epoll_create int epoll_create(int size); 此系统调用用于创建一个 epoll 实例。size 参数现在已被忽略，但必须大于 0。返回一个 epoll 实例的文件描述符，失败返回 -1。 214 epoll_ctl_old int epoll_ctl_old(void); 此系统调用是 epoll_ctl 的旧版本，已过时。 215 epoll_wait_old int epoll_wait_old(void); 此系统调用是 epoll_wait 的旧版本，已过时。 216 remap_file_pages int remap_file_pages(unsigned long start, unsigned long size, unsigned long prot, unsigned long pgoff, unsigned long flags); 此系统调用用于将文件映射区域的页面重新映射到新的虚拟地址。此调用已被弃用。 217 getdents64 int getdents64(int fd, struct linux_dirent64 *dirp, unsigned int count); 此系统调用是 getdents 的 64 位版本，用于读取目录项。它用于处理具有 64 位 inode 号的文件系统。返回值为实际读取的字节数，失败返回 -1。 218 set_tid_address long set_tid_address(int *tidptr); 此系统调用用于设置一个地址，当线程终止时，内核会将线程的 TID 写入该地址，并可能发送一个信号。这对于实现线程库非常有用。返回值为线程 ID。 219 restart_syscall long restart_syscall(void); 此系统调用用于在从信号处理函数返回后重新启动一个被中断的系统调用。它通常由内核在后台自动调用。 220 semtimedop int semtimedop(int semid, struct sembuf *sops, size_t nsops, const struct timespec *timeout); 此系统调用是 semop 的一个版本，它允许指定一个超时时间。如果信号量操作无法在超时时间内完成，则调用会返回。成功返回 0，失败返回 -1。 221 fadvise64 int fadvise64(int fd, off64_t offset, off64_t len, int advice); 此系统调用用于对文件数据进行预读和缓存策略的建议。它告诉内核应用程序将如何访问文件，以便内核可以优化其 IO 行为。成功返回 0，失败返回 -1。 222 timer_create int timer_create(clockid_t clockid, struct sigevent *sevp, timer_t *timerid); 此系统调用用于创建一个新的 POSIX 计时器。clockid 指定时钟类型，sevp 指定计时器到期时要发送的通知事件，timerid 用于存储新的计时器 ID。成功返回 0，失败返回 -1。 223 timer_settime int timer_settime(timer_t timerid, int flags, const struct itimerspec *new_value, struct itimerspec *old_value); 此系统调用用于设置或修改指定的 POSIX 计时器。timerid 指定计时器，new_value 设置新的到期时间和间隔。成功返回 0，失败返回 -1。 224 timer_gettime int timer_gettime(timer_t timerid, struct itimerspec *curr_value); 此系统调用用于获取指定的 POSIX 计时器的当前值。curr_value 结构体用于存储剩余时间和间隔。成功返回 0，失败返回 -1。 225 timer_getoverrun int timer_getoverrun(timer_t timerid); 此系统调用用于获取指定的 POSIX 计时器的到期溢出计数。它返回计时器到期时，由于进程未及时处理而错过的信号数。返回值为溢出计数，失败返回 -1。 226 timer_delete int timer_delete(timer_t timerid); 此系统调用用于删除指定的 POSIX 计时器。成功返回 0，失败返回 -1。 227 clock_settime int clock_settime(clockid_t clockid, const struct timespec *tp); 此系统调用用于设置指定时钟的时间。clockid 指定时钟类型，tp 结构体包含了新的时间。成功返回 0，失败返回 -1。 228 clock_gettime int clock_gettime(clockid_t clockid, struct timespec *tp); 此系统调用用于获取指定时钟的当前时间。tp 结构体用于存储时间。成功返回 0，失败返回 -1。 229 clock_getres int clock_getres(clockid_t clockid, struct timespec *res); 此系统调用用于获取指定时钟的分辨率（即最小可测量的时间间隔）。res 结构体用于存储分辨率。成功返回 0，失败返回 -1。 230 clock_nanosleep int clock_nanosleep(clockid_t clockid, int flags, const struct timespec *request, struct timespec *remain); 此系统调用用于在高精度时钟上暂停执行。它比 nanosleep 更灵活，允许指定时钟类型和相对绝对时间。成功返回 0，失败返回 -1。 231 exit_group void exit_group(int status); 此系统调用用于终止调用进程所属的整个线程组。status 参数是一个整数，作为进程的退出状态码。与 exit 不同，它会终止所有线程，而不仅仅是调用线程。此调用永不返回。 232 epoll_wait int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 此系统调用用于等待 epoll 实例上的事件。它阻塞直到 epfd 上的事件发生或超时。就绪的事件被存储在 events 数组中。返回值为就绪事件的数量，失败返回 -1。 233 epoll_ctl int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 此系统调用用于控制 epoll 实例。op 指定操作类型，如添加（EPOLL_CTL_ADD）、修改（EPOLL_CTL_MOD）或删除（EPOLL_CTL_DEL）文件描述符 fd。成功返回 0，失败返回 -1。 234 tgkill int tgkill(int tgid, int tid, int sig); 此系统调用用于向指定的线程 tid 发送信号。它通过指定线程组 ID（tgid）来确保目标线程属于正确的进程。成功返回 0，失败返回 -1。 235 utimes int utimes(const char *filename, const struct timeval times[2]); 此系统调用用于改变指定文件 filename 的访问和修改时间。它比 utime 提供了更高的精度，支持微秒。成功返回 0，失败返回 -1。 236 vserver int vserver(void); 此系统调用用于虚拟化服务器。该调用已被弃用，因为虚拟化技术已经通过其他方式实现。 237 mbind long mbind(unsigned long start, unsigned long len, unsigned long mode, unsigned long *nmask, unsigned long maxnode, unsigned flags); 此系统调用用于将一个进程的内存区域绑定到一组指定的 NUMA（非均匀内存访问）节点。这有助于在 NUMA 架构上优化内存访问。成功返回 0，失败返回 -1。 238 set_mempolicy long set_mempolicy(int mode, const unsigned long *nmask, unsigned long maxnode); 此系统调用用于设置调用进程的默认内存分配策略。mode 指定策略，nmask 指定要使用的 NUMA 节点。成功返回 0，失败返回 -1。 239 get_mempolicy long get_mempolicy(int *mode, unsigned long *nmask, unsigned long maxnode, unsigned long addr, unsigned long flags); 此系统调用用于获取调用进程的内存分配策略或指定地址的策略。成功返回 0，失败返回 -1。 240 mq_open mqd_t mq_open(const char *name, int oflag, ...); 此系统调用用于打开或创建一个 POSIX 消息队列。name 指定队列名称，oflag 指定打开标志。成功返回消息队列描述符，失败返回 -1。 241 mq_unlink int mq_unlink(const char *name); 此系统调用用于删除指定的 POSIX 消息队列。name 指定要删除的队列名称。成功返回 0，失败返回 -1。 242 mq_timedsend int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio, const struct timespec *abs_timeout); 此系统调用用于向消息队列发送消息，并指定一个绝对超时时间。如果无法在超时时间内发送消息，则调用失败。成功返回 0，失败返回 -1。 243 mq_timedreceive ssize_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio, const struct timespec *abs_timeout); 此系统调用用于从消息队列接收消息，并指定一个绝对超时时间。如果无法在超时时间内接收消息，则调用失败。成功返回接收的字节数，失败返回 -1。 244 mq_notify int mq_notify(mqd_t mqdes, const struct sigevent *sevp); 此系统调用用于注册或取消消息队列的通知。sevp 结构体指定当消息到达一个空队列时，要发送的通知类型。成功返回 0，失败返回 -1。 245 mq_getsetattr int mq_getsetattr(mqd_t mqdes, const struct mq_attr *newattr, struct mq_attr *oldattr); 此系统调用用于获取或设置消息队列的属性。newattr 指定新的属性，oldattr 用于获取旧的属性。成功返回 0，失败返回 -1。 246 kexec_load long kexec_load(unsigned long entry, unsigned long nr_segments, struct kexec_segment *segments, unsigned long flags); 此系统调用用于加载一个新的内核镜像，以便在不重启物理机器的情况下启动它。entry 指定新内核的入口点，segments 描述内核和初始 RAM 盘的内存布局。成功返回 0，失败返回 -1。 247 waitid int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); 此系统调用用于等待一个子进程状态的改变。它比 waitpid 更灵活，允许指定要等待的进程类型和 ID，并提供更详细的信号信息。成功返回 0，失败返回 -1。 248 add_key key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t keyring); 此系统调用用于向内核密钥环添加一个新的密钥。type 指定密钥类型，description 提供了描述，payload 是密钥数据。成功返回新密钥的序列号，失败返回 -1。 249 request_key key_serial_t request_key(const char *type, const char *description, const char *callout_info, key_serial_t keyring); 此系统调用用于从内核密钥环中查找一个密钥。如果密钥不存在，它会尝试调用 keyctl 实用程序来获取。成功返回找到的密钥的序列号，失败返回 -1。 250 keyctl long keyctl(int operation, ...); 此系统调用用于对内核密钥环执行各种操作。operation 指定操作类型，例如获取密钥属性（KEYCTL_GET_KEYRING_ID）或链接密钥（KEYCTL_LINK）。成功返回取决于操作类型，失败返回 -1。 251 ioprio_set int ioprio_set(int which, int who, int ioprio); 此系统调用用于设置进程、进程组或用户的 IO 调度优先级。ioprio 指定新的优先级值。成功返回 0，失败返回 -1。 252 ioprio_get int ioprio_get(int which, int who); 此系统调用用于获取进程、进程组或用户的 IO 调度优先级。返回值为优先级值，失败返回 -1。 253 inotify_init int inotify_init(void); 此系统调用用于初始化一个 inotify 实例，并返回一个文件描述符。inotify 实例用于监视文件系统的事件。返回值为文件描述符，失败返回 -1。 254 inotify_add_watch int inotify_add_watch(int fd, const char *pathname, uint32_t mask); 此系统调用用于向 inotify 实例添加一个监视。fd 是 inotify 实例的文件描述符，pathname 指定要监视的文件，mask 指定要监视的事件类型。成功返回监视描述符，失败返回 -1。 255 inotify_rm_watch int inotify_rm_watch(int fd, int wd); 此系统调用用于从 inotify 实例中移除一个监视。fd 是 inotify 实例的文件描述符，wd 是要移除的监视描述符。成功返回 0，失败返回 -1。 256 migrate_pages long migrate_pages(int pid, unsigned long maxnode, const unsigned long *old_nodes, const unsigned long *new_nodes); 此系统调用用于将指定进程的内存页面从一组 NUMA 节点迁移到另一组。old_nodes 和 new_nodes 分别指定源和目标节点。成功返回迁移的页面数，失败返回 -1。 257 openat int openat(int dirfd, const char *pathname, int flags, ...); 此系统调用是 open 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。这可以防止在文件路径中存在符号链接攻击。成功返回新的文件描述符，失败返回 -1。 258 mkdirat int mkdirat(int dirfd, const char *pathname, mode_t mode); 此系统调用是 mkdir 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。成功返回 0，失败返回 -1。 259 mknodat int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev); 此系统调用是 mknod 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。成功返回 0，失败返回 -1。 260 fchownat int fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags); 此系统调用是 chown 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点，并支持额外的标志，如 AT_EMPTY_PATH。成功返回 0，失败返回 -1。 261 futimesat int futimesat(int dirfd, const char *pathname, const struct timeval times[2]); 此系统调用是 utimes 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。成功返回 0，失败返回 -1。 262 newfstatat int newfstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags); 此系统调用是 fstatat 的一个版本。它获取指定文件的状态信息，并支持额外的标志，如 AT_SYMLINK_NOFOLLOW。成功返回 0，失败返回 -1。 263 unlinkat int unlinkat(int dirfd, const char *pathname, int flags); 此系统调用是 unlink 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。flags 参数可用于指定是删除文件还是目录。成功返回 0，失败返回 -1。 264 renameat int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath); 此系统调用是 rename 的一个版本，它允许在两个不同的目录中进行重命名操作。olddirfd 和 newdirfd 分别指定源和目标目录。成功返回 0，失败返回 -1。 265 linkat int linkat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags); 此系统调用是 link 的一个版本，它允许在两个不同的目录中创建硬链接。flags 参数可用于控制符号链接的行为。成功返回 0，失败返回 -1。 266 symlinkat int symlinkat(const char *target, int newdirfd, const char *linkpath); 此系统调用是 symlink 的一个版本，它允许在指定的目录中创建符号链接。成功返回 0，失败返回 -1。 267 readlinkat ssize_t readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz); 此系统调用是 readlink 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。返回值为读取的字节数，失败返回 -1。 268 fchmodat int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags); 此系统调用是 chmod 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。成功返回 0，失败返回 -1。 269 faccessat int faccessat(int dirfd, const char *pathname, int mode, int flags); 此系统调用是 access 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点。成功返回 0，失败返回 -1。 270 pselect6 int pselect6(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask); 此系统调用是 select 的一个版本，它允许原子性地改变信号掩码和等待文件描述符事件。timeout 参数以纳秒为单位。返回值为就绪的文件描述符总数，失败返回 -1。 271 ppoll int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask); 此系统调用是 poll 的一个版本，它允许原子性地改变信号掩码和等待文件描述符事件。tmo_p 参数以纳秒为单位。返回值为就绪的文件描述符总数，失败返回 -1。 272 unshare int unshare(int flags); 此系统调用用于将调用进程从其父进程的共享资源中分离出来，从而创建新的命名空间。flags 参数指定要分离的资源类型，如文件系统、PID 或网络。成功返回 0，失败返回 -1。 273 set_robust_list int set_robust_list(struct robust_list_head *head, size_t len); 此系统调用用于为调用进程设置一个健壮的互斥锁列表。该列表用于在进程崩溃时自动释放互斥锁，从而防止死锁。成功返回 0，失败返回 -1。 274 get_robust_list int get_robust_list(int pid, struct robust_list_head **head_ptr, size_t *len_ptr); 此系统调用用于获取指定进程的健壮互斥锁列表。成功返回 0，失败返回 -1。 275 splice ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags); 此系统调用用于在两个文件描述符之间移动数据，无需通过用户空间缓冲区。它通过内核缓冲区进行数据传输，提供了非常高效的零拷贝 IO。成功返回传输的字节数，失败返回 -1。 276 tee ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags); 此系统调用用于在两个文件描述符之间复制数据，无需通过用户空间缓冲区。它从 fd_in 复制 len 字节数据到 fd_out，同时保持 fd_in 上的数据不变。成功返回复制的字节数，失败返回 -1。 277 sync_file_range int sync_file_range(int fd, off64_t offset, off64_t nbytes, unsigned int flags); 此系统调用用于将文件的一部分数据（在指定范围内）同步到磁盘。它提供了比 fsync 更细粒度的控制，可以只同步文件的部分区域。成功返回 0，失败返回 -1。 278 vmsplice ssize_t vmsplice(int fd, const struct iovec *iov, unsigned long nr_segs, unsigned int flags); 此系统调用用于将用户空间缓冲区中的数据移动到内核缓冲区，并将其链接到文件描述符。它允许高效地将多个不连续的内存区域传输到文件或套接字。成功返回传输的字节数，失败返回 -1。 279 move_pages long move_pages(int pid, unsigned long nr_pages, const void **pages, const int *nodes, int *status, int flags); 此系统调用用于将指定进程的内存页面移动到指定的 NUMA 节点。这可以用于优化 NUMA 架构上的内存访问。成功返回移动的页面数，失败返回 -1。 280 utimensat int utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags); 此系统调用是 utimes 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点，并且支持纳秒精度。成功返回 0，失败返回 -1。 281 epoll_pwait int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask); 此系统调用是 epoll_wait 的一个版本，它允许原子性地改变信号掩码并等待事件。这对于在多线程环境中安全地处理信号非常有用。返回值为就绪事件的数量，失败返回 -1。 282 signalfd int signalfd(int fd, const sigset_t *mask, int flags); 此系统调用用于创建一个新的文件描述符，用于接收信号。当指定信号发送到进程时，信号信息将以 signalfd_siginfo 结构体的形式写入此文件描述符。返回值为文件描述符，失败返回 -1。 283 timerfd_create int timerfd_create(int clockid, int flags); 此系统调用用于创建一个新的文件描述符，该描述符可用于接收计时器到期事件。clockid 指定时钟类型，flags 提供选项。返回值为文件描述符，失败返回 -1。 284 eventfd int eventfd(unsigned int initval, int flags); 此系统调用用于创建一个新的文件描述符，作为事件通知机制。它可以用于线程或进程间的同步。返回值为文件描述符，失败返回 -1。 285 fallocate int fallocate(int fd, int mode, off_t offset, off_t len); 此系统调用用于预先分配一个文件的磁盘空间。它确保文件有足够的空间，而无需实际写入数据。成功返回 0，失败返回 -1。 286 timerfd_settime int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value); 此系统调用用于设置或修改 timerfd 文件描述符的计时器。new_value 指定新的到期时间和间隔。成功返回 0，失败返回 -1。 287 timerfd_gettime int timerfd_gettime(int fd, struct itimerspec *curr_value); 此系统调用用于获取 timerfd 文件描述符的计时器当前值。curr_value 结构体用于存储剩余时间和间隔。成功返回 0，失败返回 -1。 288 accept4 int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags); 此系统调用是 accept 的一个版本，它允许在接受连接时指定额外的标志，如 SOCK_NONBLOCK 或 SOCK_CLOEXEC。成功返回新的文件描述符，失败返回 -1。 289 signalfd4 int signalfd4(int fd, const sigset_t *mask, int flags); 此系统调用是 signalfd 的一个版本，它接受一个额外的标志参数，例如 SFD_CLOEXEC。 290 eventfd2 int eventfd2(unsigned int initval, int flags); 此系统调用是 eventfd 的一个版本，它接受一个额外的标志参数，例如 EFD_CLOEXEC。 291 epoll_create1 int epoll_create1(int flags); 此系统调用是 epoll_create 的一个版本，它允许指定额外的标志，如 EPOLL_CLOEXEC。返回一个 epoll 实例的文件描述符，失败返回 -1。 292 dup3 int dup3(int oldfd, int newfd, int flags); 此系统调用是 dup2 的一个版本，它允许指定额外的标志，如 O_CLOEXEC。成功返回 newfd，失败返回 -1。 293 pipe2 int pipe2(int pipefd[2], int flags); 此系统调用是 pipe 的一个版本，它允许指定额外的标志，如 O_CLOEXEC 或 O_NONBLOCK。成功返回 0，失败返回 -1。 294 inotify_init1 int inotify_init1(int flags); 此系统调用是 inotify_init 的一个版本，它允许指定额外的标志，如 IN_CLOEXEC 或 IN_NONBLOCK。返回一个 inotify 实例的文件描述符，失败返回 -1。 295 preadv ssize_t preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset); 此系统调用是 readv 的一个版本，它允许在指定偏移量 offset 处读取数据，而无需改变文件描述符的当前位置。返回值为读取的总字节数，失败返回 -1。 296 pwritev ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt, off_t offset); 此系统调用是 writev 的一个版本，它允许在指定偏移量 offset 处写入数据，而无需改变文件描述符的当前位置。返回值为写入的总字节数，失败返回 -1。 297 rt_tgsigqueueinfo int rt_tgsigqueueinfo(int tgid, int tid, int sig, siginfo_t *uinfo); 此系统调用是 rt_sigqueueinfo 的一个版本，它接受线程组 ID tgid，从而确保信号发送到正确的线程组。成功返回 0，失败返回 -1。 298 perf_event_open int perf_event_open(struct perf_event_attr *attr, pid_t pid, int cpu, int group_fd, unsigned long flags); 此系统调用用于创建和打开一个性能监控事件。它用于分析 CPU 性能计数器。成功返回文件描述符，失败返回 -1。 299 recvmmsg int recvmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags, struct timespec *timeout); 此系统调用用于从套接字接收多条消息。它比循环调用 recvmsg 更高效，可以一次性接收多条消息。返回值为接收的消息数，失败返回 -1。 300 fanotify_init int fanotify_init(unsigned int flags, unsigned int event_f_flags); 此系统调用用于初始化一个 fanotify 实例，并返回一个文件描述符。fanotify 实例用于监视文件系统的事件和访问权限。返回值为文件描述符，失败返回 -1。 301 fanotify_mark int fanotify_mark(int fanotify_fd, unsigned int flags, uint64_t mask, int dfd, const char *pathname); 此系统调用用于向 fanotify 实例添加、修改或删除一个监视。它指定要监视的文件或目录。成功返回 0，失败返回 -1。 302 prlimit64 int prlimit64(pid_t pid, int resource, const struct rlimit64 *new_limit, struct rlimit64 *old_limit); 此系统调用用于获取或设置进程的资源限制。它是 setrlimit 的一个版本，支持 64 位限制。成功返回 0，失败返回 -1。 303 name_to_handle_at int name_to_handle_at(int dirfd, const char *pathname, struct file_handle *handle, int *mount_id, int flags); 此系统调用用于获取一个文件的文件句柄。文件句柄可以在文件被重命名或移动后仍然用于引用该文件。成功返回 0，失败返回 -1。 304 open_by_handle_at int open_by_handle_at(int mount_fd, struct file_handle *handle, int flags); 此系统调用用于通过文件句柄打开一个文件。这使得即使文件被重命名或移动，也可以打开它。成功返回文件描述符，失败返回 -1。 305 clock_adjtime int clock_adjtime(clockid_t clkid, struct timex *buf); 此系统调用用于调整指定时钟的时间。它比 adjtimex 更通用，支持多种时钟。成功返回 0，失败返回 -1。 306 syncfs int syncfs(int fd); 此系统调用用于将指定文件描述符所属的文件系统的所有脏数据同步到磁盘。它比 sync 更细粒度，只同步一个文件系统。成功返回 0，失败返回 -1。 307 sendmmsg int sendmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen, unsigned int flags); 此系统调用用于向套接字发送多条消息。它比循环调用 sendmsg 更高效，可以一次性发送多条消息。成功返回发送的消息数，失败返回 -1。 308 setns int setns(int fd, int nstype); 此系统调用用于将调用进程移动到指定的命名空间。fd 是一个引用命名空间的文件描述符，nstype 指定命名空间的类型。成功返回 0，失败返回 -1。 309 getcpu int getcpu(unsigned *cpu, unsigned *node, struct getcpu_cache *tcache); 此系统调用用于获取调用线程当前正在运行的 CPU 编号和 NUMA 节点编号。成功返回 0，失败返回 -1。 310 process_vm_readv ssize_t process_vm_readv(pid_t pid, const struct iovec *local_iov, unsigned long liovcnt, const struct iovec *remote_iov, unsigned long riovcnt, unsigned long flags); 此系统调用用于从另一个进程的地址空间读取数据。它将目标进程的多个不连续内存区域的数据读取到调用进程的多个不连续内存区域。成功返回读取的字节数，失败返回 -1。 311 process_vm_writev ssize_t process_vm_writev(pid_t pid, const struct iovec *local_iov, unsigned long liovcnt, const struct iovec *remote_iov, unsigned long riovcnt, unsigned long flags); 此系统调用用于向另一个进程的地址空间写入数据。它将调用进程的多个不连续内存区域的数据写入目标进程的多个不连续内存区域。成功返回写入的字节数，失败返回 -1。 312 kcmp int kcmp(pid_t pid1, pid_t pid2, int type, unsigned long idx1, unsigned long idx2); 此系统调用用于比较两个进程的内核资源。type 指定要比较的资源类型，例如文件描述符表或虚拟内存空间。成功返回 0 或 1，失败返回 -1。 313 finit_module int finit_module(int fd, const char *param_values, int flags); 此系统调用用于从已打开的文件描述符加载一个内核模块。fd 是模块文件的描述符，param_values 是模块参数。成功返回 0，失败返回 -1。 314 sched_setattr int sched_setattr(pid_t pid, const struct sched_attr *attr, unsigned int flags); 此系统调用用于设置进程的调度策略和参数。它比 sched_setscheduler 更通用，支持更灵活的调度策略。成功返回 0，失败返回 -1。 315 sched_getattr int sched_getattr(pid_t pid, struct sched_attr *attr, unsigned int size, unsigned int flags); 此系统调用用于获取进程的调度策略和参数。成功返回 0，失败返回 -1。 316 renameat2 int renameat2(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, unsigned int flags); 此系统调用是 renameat 的一个版本，它提供了额外的标志，如 RENAME_NOREPLACE（如果目标文件存在则不替换）。成功返回 0，失败返回 -1。 317 seccomp int seccomp(unsigned int operation, unsigned int flags, const char *args); 此系统调用用于设置或获取安全计算模式（seccomp）状态。它限制了进程可以调用的系统调用，从而增强安全性。成功返回 0，失败返回 -1。 318 getrandom ssize_t getrandom(void *buf, size_t buflen, unsigned int flags); 此系统调用用于从内核的加密安全伪随机数生成器中获取随机字节。buf 用于存储随机数据，buflen 指定长度。成功返回获取的字节数，失败返回 -1。 319 memfd_create int memfd_create(const char *name, unsigned int flags); 此系统调用用于创建一个内存文件，并返回一个文件描述符。该文件只存在于内存中，可以被其他进程访问。成功返回文件描述符，失败返回 -1。 320 kexec_file_load long kexec_file_load(int kernel_fd, int initrd_fd, unsigned long cmdline_len, const char *cmdline_ptr, unsigned long flags); 此系统调用用于从文件描述符加载一个内核镜像，以便在不重启物理机器的情况下启动它。它比 kexec_load 更安全，因为它使用文件描述符来引用文件。成功返回 0，失败返回 -1。 321 bpf int bpf(int cmd, union bpf_attr *attr, unsigned int size); 此系统调用用于操作 BPF（Berkeley Packet Filter）程序和映射。它允许在内核中执行高效的、沙盒化的程序，用于网络过滤、跟踪等。成功返回取决于 cmd 的值，失败返回 -1。 322 execveat int execveat(int dirfd, const char *pathname, char *const argv[], char *const envp[], int flags); 此系统调用是 execve 的一个版本，它接受一个目录文件描述符 dirfd 作为相对路径的起点，并支持额外的标志，如 AT_EMPTY_PATH。成功时永不返回，失败返回 -1。 323 userfaultfd int userfaultfd(int flags); 此系统调用用于创建一个用户空间页面错误处理程序的文件描述符。它允许用户空间的应用程序处理由自身或另一个进程产生的页面错误。成功返回文件描述符，失败返回 -1。 324 membarrier int membarrier(int cmd, int flags); 此系统调用用于在所有线程上提供一个内存屏障，以确保所有 CPU 的内存视图同步。这对于跨线程或跨进程的内存一致性至关重要。成功返回 0，失败返回 -1。 325 mlock2 int mlock2(const void *addr, size_t len, int flags); 此系统调用是 mlock 的一个版本，它提供了额外的标志，如 MLOCK_ONFAULT，可以延迟锁定，直到访问到该页面。成功返回 0，失败返回 -1。 326 copy_file_range ssize_t copy_file_range(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags); 此系统调用用于在两个文件描述符之间复制数据，无需通过用户空间缓冲区。它通过内核进行零拷贝复制，提供了非常高效的文件复制。成功返回复制的字节数，失败返回 -1。 327 preadv2 ssize_t preadv2(int fd, const struct iovec *iov, unsigned long iovcnt, off_t offset, int flags); 此系统调用是 preadv 的一个版本，它提供了额外的标志，如 RWF_HIPRI（高优先级）或 RWF_APPEND。成功返回读取的总字节数，失败返回 -1。 328 pwritev2 ssize_t pwritev2(int fd, const struct iovec *iov, unsigned long iovcnt, off_t offset, int flags); 此系统调用是 pwritev 的一个版本，它提供了额外的标志，如 RWF_HIPRI。成功返回写入的总字节数，失败返回 -1。 329 pkey_mprotect int pkey_mprotect(void *addr, size_t len, int prot, int pkey); 此系统调用是 mprotect 的一个版本，它允许使用内存保护键（pkey）来控制内存访问。这提供了更细粒度的内存保护。成功返回 0，失败返回 -1。 330 pkey_alloc int pkey_alloc(unsigned int flags, unsigned int access_rights); 此系统调用用于分配一个未使用的内存保护键。flags 和 access_rights 指定键的属性。成功返回新的保护键，失败返回 -1。 331 pkey_free int pkey_free(int pkey); 此系统调用用于释放一个内存保护键。成功返回 0，失败返回 -1。 332 statx int statx(int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *statxbuf); 此系统调用是 stat 的一个新版本，它提供了更多的文件信息，并允许在单个调用中获取多种属性。mask 指定要获取的属性，statxbuf 结构体用于存储结果。成功返回 0，失败返回 -1。 333 io_pgetevents int io_pgetevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events, struct timespec *timeout, const sigset_t *sigmask); 此系统调用是 io_getevents 的一个版本，它允许原子性地改变信号掩码并检索事件。这对于处理信号和异步 IO 事件非常有用。返回值为获取的事件数，失败返回 -1。 334 rseq int rseq(struct rseq *rseq, uint32_t rseq_len, int flags, uint32_t sig); 此系统调用用于注册或取消一个 rseq（可重启序列）结构。rseq 是一种用于实现高效用户空间原子操作的机制，特别是在 NUMA 系统上。成功返回 0，失败返回 -1。 335 uretprobe int uretprobe(int type, int arg); 此系统调用用于在用户空间的函数返回时设置探针。此调用已过时，推荐使用 bpf。 424 pidfd_send_signal int pidfd_send_signal(int pidfd, int sig, siginfo_t *info, unsigned int flags); 此系统调用用于向由文件描述符 pidfd 指定的进程发送信号。pidfd 提供了比传统 PID 更健壮的进程引用方式。成功返回 0，失败返回 -1。 425 io_uring_setup int io_uring_setup(unsigned int entries, struct io_uring_params *params); 此系统调用用于创建和初始化一个 io_uring 实例。entries 指定队列中的条目数，params 提供了额外的参数。io_uring 是一种高性能异步 IO 接口。成功返回文件描述符，失败返回 -1。 426 io_uring_enter int io_uring_enter(int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig); 此系统调用用于提交 io_uring 实例中的请求，并等待已完成的请求。它允许应用程序将请求排队并异步地处理结果。成功返回提交的请求数，失败返回 -1。 427 io_uring_register int io_uring_register(int fd, unsigned int opcode, const void *arg, unsigned int nr_args); 此系统调用用于注册 io_uring 实例中的文件描述符或缓冲区，以提高性能。它允许内核对资源进行预处理，从而减少后续的开销。成功返回 0，失败返回 -1。 428 open_tree int open_tree(int dirfd, const char *pathname, unsigned int flags); 此系统调用用于获取一个文件或目录子树的句柄，并返回一个文件描述符。这使得在不使用 chroot 的情况下，可以对文件树进行操作。成功返回文件描述符，失败返回 -1。 429 move_mount int move_mount(int from_dirfd, const char *from_pathname, int to_dirfd, const char *to_pathname, unsigned int flags); 此系统调用用于移动一个挂载点。它将一个挂载点从一个位置移动到另一个位置，而无需卸载和重新挂载。成功返回 0，失败返回 -1。 430 fsopen int fsopen(const char *fsname, unsigned int flags); 此系统调用用于创建一个新的文件系统实例。它返回一个用于配置该文件系统的文件描述符。成功返回文件描述符，失败返回 -1。 431 fsconfig int fsconfig(int fd, unsigned int cmd, const char *key, const void *value, int aux); 此系统调用用于配置一个文件系统实例。fd 是文件系统实例的文件描述符，cmd 指定操作类型，如设置选项或提交配置。成功返回 0，失败返回 -1。 432 fsmount int fsmount(int fs_fd, unsigned int flags, unsigned int ms_flags); 此系统调用用于挂载一个已配置的文件系统实例。fs_fd 是文件系统实例的文件描述符，flags 提供挂载选项。成功返回挂载的文件描述符，失败返回 -1。 433 fspick int fspick(int dirfd, const char *path, unsigned int flags); 此系统调用用于从文件树中选择一个文件或目录，并返回一个文件描述符。这可以用于在不进行符号链接遍历的情况下获取文件句柄。成功返回文件描述符，失败返回 -1。 434 pidfd_open int pidfd_open(pid_t pid, unsigned int flags); 此系统调用用于打开一个进程的文件描述符。pid 指定目标进程。pidfd 可以用于向该进程发送信号或执行其他操作，即使进程的 PID 发生变化。成功返回文件描述符，失败返回 -1。 435 clone3 int clone3(struct clone_args *cl_args, size_t size); 此系统调用是 clone 的一个新版本，它使用一个结构体来传递参数，从而提供了更好的可扩展性。它用于创建一个新的子进程或线程。成功返回子进程的 PID，失败返回 -1。 436 close_range int close_range(unsigned int first, unsigned int last, unsigned int flags); 此系统调用用于关闭指定范围内的所有文件描述符。它比循环调用 close 更高效，并且是原子性的。成功返回 0，失败返回 -1。 437 openat2 int openat2(int dirfd, const char *pathname, struct open_how *how, size_t size); 此系统调用是 openat 的一个新版本，它使用一个结构体来传递参数，从而提供了更灵活的打开选项，如对符号链接的更精细控制。成功返回文件描述符，失败返回 -1。 438 pidfd_getfd int pidfd_getfd(int pidfd, int fd, unsigned int flags); 此系统调用用于从由 pidfd 指定的进程中获取一个文件描述符的副本。成功返回新的文件描述符，失败返回 -1。 439 faccessat2 int faccessat2(int dirfd, const char *pathname, int mode, int flags); 此系统调用是 faccessat 的一个版本，它提供了额外的标志，如 AT_EACCESS，用于根据有效 UIDGID 检查权限。成功返回 0，失败返回 -1。 440 process_madvise int process_madvise(int pidfd, const struct iovec *iov, size_t iovcnt, int advice, unsigned int flags); 此系统调用用于对另一个进程的内存区域提供建议。pidfd 引用目标进程，iov 描述内存区域，advice 提供建议。成功返回 0，失败返回 -1。 441 epoll_pwait2 int epoll_pwait2(int epfd, struct epoll_event *events, int maxevents, const struct timespec *timeout, const sigset_t *sigmask); 此系统调用是 epoll_pwait 的一个版本，它使用 timespec 结构体来指定超时时间，从而支持更高的精度。返回值为就绪事件的数量，失败返回 -1。 442 mount_setattr int mount_setattr(int dirfd, const char *pathname, unsigned int flags, struct mount_attr *uattr, size_t size); 此系统调用用于设置或修改一个挂载点的属性。它比 mount 更细粒度，可以单独修改挂载属性，如只读或不可执行。成功返回 0，失败返回 -1。 443 quotactl_fd int quotactl_fd(unsigned int fd, unsigned int cmd, qid_t id, void *addr); 此系统调用是 quotactl 的一个版本，它通过文件描述符来引用文件系统。这可以避免路径名解析的潜在问题。成功返回 0，失败返回 -1。 444 landlock_create_ruleset int landlock_create_ruleset(struct landlock_ruleset_attr *attr, size_t size, unsigned int flags); 此系统调用用于创建一个新的 Landlock 规则集。Landlock 是一种用于限制进程文件系统访问权限的安全机制。成功返回规则集的文件描述符，失败返回 -1。 445 landlock_add_rule int landlock_add_rule(int ruleset_fd, enum landlock_rule_type type, const void *attr, unsigned int flags); 此系统调用用于向一个 Landlock 规则集添加规则。ruleset_fd 是规则集的文件描述符，type 指定规则类型，attr 提供了规则的详细信息。成功返回 0，失败返回 -1。 446 landlock_restrict_self int landlock_restrict_self(int ruleset_fd, unsigned int flags); 此系统调用用于将一个 Landlock 规则集应用到调用进程。这会限制进程的文件系统访问权限，一旦应用，规则集就无法被修改。成功返回 0，失败返回 -1。 447 memfd_secret int memfd_secret(unsigned int flags); 此系统调用用于创建一个秘密的内存文件，它无法被其他进程访问，即使是具有高权限的进程。这对于存储敏感数据非常有用。成功返回文件描述符，失败返回 -1。 448 process_mrelease int process_mrelease(int pidfd, unsigned int flags); 此系统调用用于释放指定进程的资源，但不会终止进程。pidfd 引用目标进程。这可以用于在不等待进程完全退出时回收资源。成功返回 0，失败返回 -1。 449 futex_waitv int futex_waitv(struct futex_waitv *waitv, unsigned int nr_futexes, int flags); 此系统调用是 futex 的一个版本，它允许在一个原子操作中等待多个 futex。这对于实现复杂的同步原语非常有用。成功返回 0，失败返回 -1。 450 set_mempolicy_home_node int set_mempolicy_home_node(unsigned int start, unsigned int len, unsigned int node); 此系统调用用于设置一个进程的“家”NUMA 节点，并将其内存页绑定到该节点。此调用已过时，推荐使用 mbind。 451 cachestat int cachestat(int fd, const char *path, const struct statx *stx, unsigned int flags, struct cachestat *result); 此系统调用用于获取文件页面缓存的统计信息。fd 和 path 指定文件，result 结构体用于存储缓存命中、丢失等信息。成功返回 0，失败返回 -1。 452 fchmodat2 int fchmodat2(int dirfd, const char *pathname, mode_t mode, unsigned int flags); 此系统调用是 fchmodat 的一个版本，它提供了额外的标志，如 AT_SYMLINK_NOFOLLOW。成功返回 0，失败返回 -1。 453 map_shadow_stack unsigned long map_shadow_stack(unsigned long addr, unsigned long size, unsigned int flags); 此系统调用用于为进程创建一个影子栈。影子栈是一种安全机制，用于保护函数返回地址不被缓冲区溢出等攻击篡改。成功返回影子栈的地址，失败返回 -1。 454 futex_wake int futex_wake(int *uaddr, int nr_wake); 此系统调用是 futex 的一个版本，专门用于唤醒在指定 uaddr 上等待的线程。nr_wake 指定要唤醒的最大线程数。成功返回唤醒的线程数，失败返回 -1。 455 futex_wait int futex_wait(int *uaddr, int val); 此系统调用是 futex 的一个版本，专门用于等待。它在 uaddr 上等待，直到其值不等于 val。成功返回 0，失败返回 -1。 456 futex_requeue int futex_requeue(int *uaddr, int nr_wake, int *uaddr2, int nr_requeue); 此系统调用是 futex 的一个版本，它允许在单个原子操作中唤醒一个 futex 上的线程，并将其余线程重新排队到另一个 futex 上。成功返回 0，失败返回 -1。 457 statmount int statmount(const char *pathname, struct statmount *statbuf); 此系统调用用于获取一个挂载点的状态信息。此调用已过时。 458 listmount int listmount(const char *pathname, void *buf, size_t bufsize); 此系统调用用于列出一个挂载点下的所有子挂载点。此调用已过时。 459 lsm_get_self_attr int lsm_get_self_attr(const char *attr, void *value, size_t len); 此系统调用用于获取当前进程的 Linux 安全模块（LSM）属性。attr 指定属性名称。成功返回 0，失败返回 -1。 460 lsm_set_self_attr int lsm_set_self_attr(const char *attr, const void *value, size_t len, int flags); 此系统调用用于设置当前进程的 Linux 安全模块（LSM）属性。成功返回 0，失败返回 -1。 461 lsm_list_modules int lsm_list_modules(void *buf, size_t len); 此系统调用用于列出所有已启用的 Linux 安全模块（LSM）。buf 用于存储模块名称列表。成功返回列表的大小，失败返回 -1。 462 mseal int mseal(void *addr, size_t len, unsigned int flags); 此系统调用用于对一个内存映射区域进行密封。一旦密封，该区域的某些属性（如可写性）就无法再更改，从而增强安全性。成功返回 0，失败返回 -1。","tags":["Linux"]},{"title":"Hello world！","path":"/2025/11/12/Hello-world！/","content":"一级标题这是 Markdown 渲染测试文档，用于验证： 普通文本是否显示正常 各种语法（标题、列表、链接、图片、代码、表格等） 是否支持数学公式（需启用 hexo-renderer-markdown-it + markdown-it-katex 或 mathjax） 二级标题1. 文本格式普通文字加粗文字斜体文字~删除线文字~~高亮文字（部分主题支持） 这是一个引用区块，可以用于强调一句话。 2. 无序与有序列表无序列表 苹果 🍎 香蕉 🍌 西瓜 🍉 有序列表 第一项 第二项 第三项 3. 代码块与语法高亮行内代码在行内可以使用反引号：printf(Hello World); 多行代码#include iostreamusing namespace std;int main() cout Hello Hexo Markdown! endl; return 0; 4. 表格 姓名 年龄 爱好 小明 18 篮球 小红 20 阅读 小刚 22 编程 5. 链接与图片访问 Hexo 官网 6. 数学公式行内公式这是行内公式：$E mc^2$。 独立公式（块级公式）$$\\int_{0}^{\\infty} e^{-x^2} dx \\frac{\\sqrt{\\pi}}{2}$$ $$a^2 + b^2 c^2$$ ⚠️ 注意：要显示数学公式，你需要启用 MathJax 或 KaTeX。例如在 _config.yml（或主题配置）中开启： math: enable: true engine: mathjax 7. 引用与提示框（部分主题支持） 💡 提示：Hexo 可以用来写技术笔记、数学博客、读书笔记等。 ⚠️ 警告：生成静态文件后记得执行 hexo clean hexo g。 8. 分隔线与脚注 这是一个脚注示例^1。 9. 嵌入 HTML（部分主题支持） 这是嵌入的 HTML 示例 可以用于居中内容或自定义样式 ✅ 总结这篇文章展示了以下内容： 功能 是否测试 文本格式 ✅ 列表 ✅ 代码高亮 ✅ 图片与链接 ✅ 表格 ✅ 数学公式 ✅ HTML ✅ 恭喜 🎉如果你的页面渲染正确，说明 Hexo 的 Markdown 解析器配置是正常的！"}]